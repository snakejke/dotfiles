;-*- eval: (load-file "./init-dev.el");   -*-
#+title: Emacs config
#+property: header-args :mkdirp yes :tangle yes :tangle-mode: #o444 :results silent :noweb yes
#+startup: content

* TODO early-init
:PROPERTIES:
:header-args: :tangle-mode o444 :results silent :tangle ~/.config/emacs/early-init.el
:END:
#+begin_src emacs-lisp :lexical t
;;; early-init.el --- Emacs pre package.el & GUI configuration -*- lexical-binding: t; -*-
;;; Code:
#+end_src

#+begin_src emacs-lisp :lexical t
(setq package-enable-at-startup nil)
(setq inhibit-default-init nil)
#+end_src

#+begin_src emacs-lisp :lexical t
(setq native-comp-async-report-warnings-errors nil)
#+end_src
** Debugging 
Running this form will launch the debugger after loading a package.
This is useful for finding out when a dependency is requiring a package (perhaps earlier than you want).
Use by tangling this block and launching Emacs with =emacs --debug-init=.

#+begin_src emacs-lisp :var file="" :results silent :tangle no
(unless (string-empty-p file)
  (eval-after-load file
    '(debug)))
#+end_src

Similarly, this variable will hit the debugger when a message matches its regexp.
#+begin_src emacs-lisp :tangle no
(setq debug-on-message "")
#+end_src

Adding a variable watcher can be a useful way to track down initialization and mutation of a variable.
#+begin_src emacs-lisp :tangle no
(add-variable-watcher 'org-capture-after-finalize-hook
                      (lambda (symbol newval operation where)
                        (debug)
                        (message "%s set to %s" symbol newval)))
#+end_src

#+begin_src emacs-lisp :tangle no
(setq debug-on-error t)
#+end_src

** Оптимизация file-name-handler-alist
Пропуск  регулярных выражений в  =file-name-handler-alist= .  из Дума ?
#+begin_src emacs-lisp :lexical t
(defvar default-file-name-handler-alist file-name-handler-alist)
(setq file-name-handler-alist nil)
#+end_src
** TODO Папка с кешем
Переместить в другое место ?
#+begin_src emacs-lisp :lexical t
(when (boundp 'native-comp-eln-load-path)
  (setcar native-comp-eln-load-path
          (expand-file-name "cache/eln-cache/" user-emacs-directory)))
#+end_src

** Настройка Garbage Collection

#+begin_src emacs-lisp :lexical t 
(setq gc-cons-threshold most-positive-fixnum
      gc-cons-percentage 1)

(defun +gc-after-focus-change ()
  "Run GC when frame loses focus."
  (run-with-idle-timer
   5 nil
   (lambda () (unless (frame-focus-state) (garbage-collect)))))
#+end_src

#+begin_src emacs-lisp :lexical t 
(defun +reset-init-values ()
  (run-with-idle-timer
   1 nil
   (lambda ()
     (setq file-name-handler-alist default-file-name-handler-alist
           gc-cons-percentage 0.1
           gc-cons-threshold 100000000)
     (message "gc-cons-threshold & file-name-handler-alist restored")
     (when (boundp 'after-focus-change-function)
       (add-function :after after-focus-change-function #'+gc-after-focus-change)))))

(with-eval-after-load 'elpaca
  (add-hook 'elpaca-after-init-hook '+reset-init-values))
#+end_src

** Преднастройка ui и некоторый тюнинг. 
*** Отключаем tool-bar, menu-bar, vertical-scroll
#+begin_src emacs-lisp :lexical t
(push '(menu-bar-lines . 0) default-frame-alist)
(push '(tool-bar-lines . 0) default-frame-alist)
(push '(vertical-scroll-bars) default-frame-alist)
#+end_src

*** Отключаем инструкции как закрывать emacsclient
#+begin_src emacs-lisp :lexical t
(setq server-client-instructions nil)
#+end_src
*** Не менять размер фрейма в зависимости от шрифтов
+к времени запуска если nil 
#+begin_src emacs-lisp :lexical t
(setq frame-inhibit-implied-resize t)
#+end_src
*** Игнорирование настроек в  Xresources
#+begin_src emacs-lisp :lexical t
(advice-add #'x-apply-session-resources :override #'ignore)
#+end_src

*** Фикс  бага ?
Taken from:

[[https://github.com/vsemyonoff/emacsrc/blob/14649a5bafea99cc7e13e7d048e9d15aed7926ce/early-init.el]]

This helps with a bug I was hitting when using =desktop-save-mode='s =desktop-read=.
#+begin_src emacs-lisp :lexical t
(setq desktop-restore-forces-onscreen nil)
#+end_src

*** Шрифты 

#+begin_src emacs-lisp :lexical t
;;(push '(font . "PT Serif") default-frame-alist)
(push '(font . "JetBrainsMono Nerd Font") default-frame-alist)
(set-face-font 'default "JetBrainsMono Nerd Font")
(set-face-font 'variable-pitch "IBM Plex Serif")
(copy-face 'default 'fixed-pitch)
#+end_src
*** Отключаем функцию звонка
#+begin_src emacs-lisp :lexical t
(setq ring-bell-function #'ignore
      inhibit-startup-screen t)
#+end_src

#+begin_src emacs-lisp :lexical t
(provide 'early-init)
;;; early-init.el ends here
#+end_src

* lexical binding. начало init.el
#+begin_src emacs-lisp :lexical t
;; -*- lexical-binding: t; -*-
#+end_src
* Профилирование 
** Проверки времени запуска
#+begin_src emacs-lisp :lexical t
(add-hook 'elpaca-after-init-hook
          (lambda ()
            (message "Emacs loaded in %s with %d garbage collections."
                     (format "%.2f seconds"
                             (float-time
                              (time-subtract (current-time) before-init-time)))
                     gcs-done)))
#+end_src

** Запуск profilling 
#+begin_src emacs-lisp :lexical t :tangle no
(profiler-start 'cpu+mem)
(add-hook 'elpaca-after-init-hook (lambda () (profiler-stop) (profiler-report)))
#+end_src
** Поиск "горячих" функций 
ELP полезен для поиска горячих функций
#+begin_src emacs-lisp :var file="elpaca" :lexical t :tangle no
(require 'elp)
(with-eval-after-load file
  (elp-instrument-package file))
(add-hook 'elpaca-after-init-hook
          (lambda () (elp-results) (elp-restore-package (intern file))))
#+end_src
* Стартовый буфер initial-buffer-choice
#+begin_src emacs-lisp :lexical t
(setq initial-buffer-choice t) ;;*scratch*
#+end_src
* Пример хранения тем в отдельной директории. 
=~/.emacs.d=
#+begin_src emacs-lisp :lexical t :tangle no
(setq custom-theme-directory "~/.emacs.d/themes/")
#+end_src

#+begin_src emacs-lisp :lexical t :tangle no
(defvar +theme 'mine "Default theme.")
(require 'cl-lib)
(require 'custom)
;; remove synthetic use-package theme
(unless (remq 'use-package custom-enabled-themes) (load-theme +theme t))
#+end_src

* Elpaca настройка
** Основные настройки elpaca
#+begin_src emacs-lisp :lexical t
(defvar elpaca-installer-version 0.8)
(defvar elpaca-directory (expand-file-name "elpaca/" user-emacs-directory))
(defvar elpaca-builds-directory (expand-file-name "builds/" elpaca-directory))
(defvar elpaca-repos-directory (expand-file-name "repos/" elpaca-directory))
(defvar elpaca-order '(elpaca :repo "https://github.com/progfolio/elpaca.git"
                              :ref nil :depth 1
                              :files (:defaults "elpaca-test.el" (:exclude "extensions"))
                              :build (:not elpaca--activate-package)))
(let* ((repo  (expand-file-name "elpaca/" elpaca-repos-directory))
       (build (expand-file-name "elpaca/" elpaca-builds-directory))
       (order (cdr elpaca-order))
       (default-directory repo))
  (add-to-list 'load-path (if (file-exists-p build) build repo))
  (unless (file-exists-p repo)
    (make-directory repo t)
    (when (< emacs-major-version 28) (require 'subr-x))
    (condition-case-unless-debug err
        (if-let* ((buffer (pop-to-buffer-same-window "*elpaca-bootstrap*"))
                  ((zerop (apply #'call-process `("git" nil ,buffer t "clone"
                                                  ,@(when-let* ((depth (plist-get order :depth)))
                                                      (list (format "--depth=%d" depth) "--no-single-branch"))
                                                  ,(plist-get order :repo) ,repo))))
                  ((zerop (call-process "git" nil buffer t "checkout"
                                        (or (plist-get order :ref) "--"))))
                  (emacs (concat invocation-directory invocation-name))
                  ((zerop (call-process emacs nil buffer nil "-Q" "-L" "." "--batch"
                                        "--eval" "(byte-recompile-directory \".\" 0 'force)")))
                  ((require 'elpaca))
                  ((elpaca-generate-autoloads "elpaca" repo)))
            (progn (message "%s" (buffer-string)) (kill-buffer buffer))
          (error "%s" (with-current-buffer buffer (buffer-string))))
      ((error) (warn "%s" err) (delete-directory repo 'recursive))))
  (unless (require 'elpaca-autoloads nil t)
    (require 'elpaca)
    (elpaca-generate-autoloads "elpaca" repo)
    (load "./elpaca-autoloads")))
(add-hook 'after-init-hook #'elpaca-process-queues)
(elpaca `(,@elpaca-order))
(setq elpaca-queue-limit 30)
#+end_src

** keychain (?)
[[https://www.funtoo.org/Keychain][Keychain]] 
#+begin_src emacs-lisp :lexical t :tangle no
;; We need this loaded for SSH protocol
(elpaca-queue
 (elpaca keychain-environment
   (require 'keychain-environment)
   (keychain-refresh-environment)))
#+end_src
** Макрос use-feature с :ensure nil для built-in пакетов.
Удобно. 
#+begin_src emacs-lisp :lexical t
(defmacro use-feature (name &rest args)
  "Like `use-package' but accounting for asynchronous installation.
  NAME and ARGS are in `use-package'."
  (declare (indent defun))
  `(use-package ,name
     :ensure nil
     ,@args))
#+end_src
** use-package всегда :ensure t
always-defer ??
#+begin_src emacs-lisp :lexical t
(elpaca elpaca-use-package
  (require 'elpaca-use-package)
  (elpaca-use-package-mode)
  (setq use-package-always-ensure t))
#+end_src

#+begin_src emacs-lisp :lexical t
(elpaca-wait)
#+end_src
** настрока debug 
#+begin_src emacs-lisp :lexical t
(if debug-on-error
    (setq use-package-verbose t
          use-package-expand-minimally nil
          use-package-compute-statistics t)
  (setq use-package-verbose nil
        use-package-expand-minimally t))
#+end_src
** Директории с личным пакетами 
#+begin_src emacs-lisp :lexical t
(let ((default-directory "~/.config/emacs/lisp"))
  (when (file-exists-p default-directory)
    (normal-top-level-add-to-load-path '("."))
    (normal-top-level-add-subdirs-to-load-path)))
#+end_src
Под notmuch 
на Void Linux  ~/usr/share/emacs/site-lisp/notmuch~ 
#+begin_src emacs-lisp :lexical t

(let ((additional-paths '("/usr/share/emacs/site-lisp/notmuch"))) 
  (mapc (lambda (path)
          (when (file-directory-p path) 
            (add-to-list 'load-path path)))
        additional-paths))
#+end_src

* literate
#+begin_src emacs-lisp :lexical t
(setq literate-file (concat user-emacs-directory "init.org"))
#+end_src
* terminal utf-8
#+begin_src emacs-lisp :lexical t
(defun +terminal ()
  "Set the terimnal coding system."
  (unless (display-graphic-p)
    (set-terminal-coding-system 'utf-8)))

(add-hook 'server-after-make-frame-hook #'+terminal)
#+end_src
* Файл с секретами
#+begin_src emacs-lisp :lexical t :tangle no
(load-file "~/Documents/emacs-secrets.el")
#+end_src
* General.el 
#+begin_src emacs-lisp :lexical t
(use-package general
  :ensure (:wait t)
  :demand t
  :config
  (general-override-mode)
  (general-auto-unbind-keys)
#+end_src
** config
*** general
#+begin_src emacs-lisp :lexical t
(general-define-key
 :keymaps 'override
 :states '(insert normal hybrid motion visual operator emacs)
 :prefix-map '+prefix-map
 :prefix "SPC"
 :global-prefix "S-SPC")

(general-create-definer global-definer
  :wk-full-keys nil
  :keymaps '+prefix-map)
#+end_src

#+begin_src emacs-lisp :lexical t
(global-definer
  "SPC" '(project-find-file :wk "Find file in project")
  ;;"/"   'occur
  "!"   'shell-command
  ";"   'pp-eval-expression
  "`"   'evil-switch-to-windows-last-buffer
  "."   'repeat
  "h"   (general-simulate-key "C-h" :which-key "help")
  "z"   '((lambda (local) (interactive "p")
            (unless repeat-mode (repeat-mode))
            (let ((local current-prefix-arg)
                  (current-prefix-arg nil))
              (call-interactively (if local #'text-scale-adjust #'global-text-scale-adjust))))
          :which-key "zoom"))
#+end_src

We define a global-leader definer to access major-mode specific bindings:

#+begin_src emacs-lisp :lexical t
(general-create-definer global-leader
  :keymaps 'override
  :states '(insert normal hybrid motion visual operator)
  :prefix "SPC m"
  :non-normal-prefix "S-SPC m"
  "" '( :ignore t
        :which-key
        (lambda (arg)
          (cons (cadr (split-string (car arg) " "))
                (replace-regexp-in-string "-mode$" "" (symbol-name major-mode))))))
#+end_src

And a macro to ease the creation of nested menu bindings:

#+begin_src emacs-lisp :lexical t
(defmacro +general-global-menu! (name prefix-key &rest body)
  "Create a definer named +general-global-NAME wrapping global-definer.
  Create prefix map: +general-global-NAME-map. Prefix bindings in BODY with PREFIX-KEY."
  (declare (indent 2))
  (let* ((n (concat "+general-global-" name))
         (prefix-map (intern (concat n "-map"))))
    `(progn
       (general-create-definer ,(intern n)
         :wrapping global-definer
         :prefix-map (quote ,prefix-map)
         :prefix ,prefix-key
         :wk-full-keys nil
         "" '(:ignore t :which-key ,name))
       (,(intern n) ,@body))))

#+end_src
*** a applications
#+begin_src emacs-lisp :lexical t
(+general-global-menu! "application" "a"
  "p" '(:ignore t "elpaca")
  "pb" 'elpaca-browse
  "pr"  '((lambda () (interactive)
            (let ((current-prefix-arg (not current-prefix-arg))
                  (this-command 'elpaca-rebuild))
              (call-interactively #'elpaca-rebuild)))
          :wk "rebuild")
  "pm" 'elpaca-manager
  "pl" 'elpaca-log
  "pi" 'elpaca-info
  "pI" '((lambda () (interactive) (info "Elpaca"))
         :wk "elpaca-info")
  "ps" 'elpaca-status
  "pt" 'elpaca-try
  "pv" 'elpaca-visit)
#+end_src
*** o open
#+begin_src emacs-lisp :lexical t
(+general-global-menu! "open" "o"
  "-"  'dired-jump
  "p"  'treemacs
  "e"  'project-eshell-popup
  )

#+end_src
*** b buffers
#+begin_src emacs-lisp :lexical t
(+general-global-menu! "buffer" "b"
  "d"  'kill-current-buffer
  "o" '((lambda () (interactive) (switch-to-buffer nil))
        :wk "other-buffer")
  "p"  'previous-buffer
  "r"  'rename-buffer
  "R"  'revert-buffer
  "i"  'ibuffer
  "M" '((lambda () (interactive) (switch-to-buffer "*Messages*"))
        :which-key "messages-buffer")
  "n"  'next-buffer
  "N"  'evil-buffer-new
  "s"  '("fdfd" . basic-save-buffer)
  "S"  '(evil-write-all :wk "Save all buffers")
  ;;"s"  'scratch-buffer
  "TAB" '((lambda () (interactive) (switch-to-buffer nil))
          :which-key "other-buffer"))
#+end_src

*** B bookmarks
#+begin_src emacs-lisp :lexical t
(+general-global-menu! "bookmark" "B")
#+end_src
*** E eval
#+begin_src emacs-lisp :lexical t
(+general-global-menu! "eval" "e"
  "b" 'eval-buffer
  "d" 'eval-defun
  "e" 'eval-expression
  "p" 'pp-eval-last-sexp
  "s" 'eval-last-sexp)
#+end_src
*** f files
#+begin_src emacs-lisp :lexical t
(+general-global-menu! "file" "f"
  ;; "d"   '((lambda (&optional arg)
  ;;           (interactive "P")
  ;;           (let ((buffer (when arg (current-buffer))))
  ;;             (diff-buffer-with-file buffer))) :which-key "diff-with-file")
  "e"   '(:ignore t :which-key "edit")
  "p"  '((lambda () (interactive) (find-file-existing literate-file) (widen))
          :which-key "dotfile")
  "f"   '(find-file :which-key "find-file")
  "l"   '((lambda (&optional arg)
            (interactive "P")
            (call-interactively (if arg #'find-library-other-window #'find-library)))
          :which-key "+find-library")
  ;;"p"   'find-function-at-point
  "P"   'find-function
  "R"   'rename-file-and-buffer
  ;;"s"   'save-buffer
  "v"   'find-variable-at-point
  "V"   'find-variable)
#+end_src
*** F frames

#+begin_src emacs-lisp :lexical t
(+general-global-menu! "frame" "F"
  "D" 'delete-other-frames
  "F" 'select-frame-by-name
  "O" 'other-frame-prefix
  "c" '(:ingore t :which-key "color")
  "cb" 'set-background-color
  "cc" 'set-cursor-color
  "cf" 'set-foreground-color
  "f" 'set-frame-font
  "m" 'make-frame-on-monitor
  "n" 'next-window-any-frame
  "o" 'other-frame
  "p" 'previous-window-any-frame
  "r" 'set-frame-name)
#+end_src
*** g git version-control
#+begin_src emacs-lisp :lexical t
(+general-global-menu! "git/version-control" "g")
#+end_src
*** l links
#+begin_src emacs-lisp :lexical t
(+general-global-menu! "link" "l")
#+end_src
*** n narrowing
#+begin_src emacs-lisp :lexical t
(+general-global-menu! "narrow" "n"
  "d" 'narrow-to-defun
  "p" 'narrow-to-page
  "r" 'narrow-to-region
  "w" 'widen)
#+end_src
*** p projects
#+begin_src emacs-lisp :lexical t
(+general-global-menu! "project" "p"
   ;;"b" '(:ignore t :which-key "buffer")
  "p" 'project-switch-project
  )
#+end_src
*** q quit
#+begin_src emacs-lisp :lexical t
(+general-global-menu! "quit" "q"
  "q" 'save-buffers-kill-emacs
  "r" 'restart-emacs
  "d" 'delete-frame
  "Q" 'kill-emacs)
#+end_src
*** s search 
#+begin_src emacs-lisp :lexical t
 (+general-global-menu! "searchhh" "s"
   "b" 'consult-line
   "p" 'consult-ripgrep)
#+end_src
*** x text
#+begin_src emacs-lisp :lexical t
(+general-global-menu! "text" "x"
  "i" 'insert-char
  "I" (general-simulate-key "C-x 8" :which-key "iso"))

#+end_src
*** t tabs
#+begin_src emacs-lisp :lexical t
;;(+general-global-menu! "tab" "t")
#+end_src
*** T toggle
#+begin_src emacs-lisp :lexical t
(+general-global-menu! "toggle" "T"
  "d" '(:ignore t :which-key "debug")
  "de" 'toggle-debug-on-error
  "dq" 'toggle-debug-on-quit
  "s" '(:ignore t :which-key "spelling"))
#+end_src
*** w windows
#+begin_src emacs-lisp :lexical t
(+general-global-menu! "window" "w"
  "?" 'split-window-vertically
  "=" 'balance-windows
  "/" 'split-window-horizontally
  "O" 'delete-other-windows
  "X" '((lambda () (interactive) (call-interactively #'other-window) (kill-buffer-and-window))
        :which-key "kill-other-buffer-and-window")
  "d" 'delete-window
  "h" 'windmove-left
  "j" 'windmove-down
  "<right>" 'evil-window-right
  "<left>" 'evil-window-left
  "<up>" 'evil-window-up
  "<down>" 'evil-window-down
  "k" 'windmove-up
  "l" 'windmove-right
  "o" 'other-window
  "t" 'window-toggle-side-windows
  "."  '(:ingore :which-key "resize")
  ".h" '((lambda () (interactive)
           (call-interactively (if (window-prev-sibling) #'enlarge-window-horizontally
                                 #'shrink-window-horizontally)))
         :which-key "divider left")
  ".l" '((lambda () (interactive)
           (call-interactively (if (window-next-sibling) #'enlarge-window-horizontally
                                 #'shrink-window-horizontally)))
         :which-key "divider right")
  ".j" '((lambda () (interactive)
           (call-interactively (if (window-next-sibling) #'enlarge-window #'shrink-window)))
         :which-key "divider up")
  ".k" '((lambda () (interactive)
           (call-interactively (if (window-prev-sibling) #'enlarge-window #'shrink-window)))
         :which-key "divider down")
  "x" 'kill-buffer-and-window)
#+end_src
*** TODO vim completion
#+begin_src emacs-lisp :lexical t
;;vim-like completion
(general-create-definer completion-def
  :prefix "C-x")
)
#+end_src
* TODO evil
** общее
#+begin_src emacs-lisp :lexical t
(use-package evil
  :demand t
  :preface (setq evil-want-keybinding nil) ;; бинды с evil-collection
  :custom
  (evil-symbol-word-search t "search by symbol with * and #.")
  (evil-shift-width 2 "Same behavior for vim's '<' and '>' commands")
  (evil-want-C-i-jump nil) ;; fix табов с org src ??
  (evil-complete-all-buffers nil) 
  (evil-want-integration t)
  (evil-search-module 'evil-search "use vim-like search instead of 'isearch")
  (evil-undo-system 'undo-redo)
  (evil-want-minibuffer nil) ;; x2 ESC в минибуфере.
  (evil-move-beyond-eol t) ;; с nil курсор цепляется при скролле изображений 
  (evil-move-cursor-back nil) ;; не делать отступ назад при esc 
  :config
  (+general-global-window
    "H" 'evil-window-move-far-left
    "J" 'evil-window-move-very-bottom
    "K" 'evil-window-move-very-top
    "L" 'evil-window-move-far-right)
  (+general-global-menu! "quit" "q"
    ":" 'evil-command-window-ex
    "/" 'evil-command-window-search-forward
    "?" 'evil-command-window-search-backward)

  (evil-mode)
)
#+end_src

** evil-collection
Коллекция evil биндов из репы progfolio. Поменять ? 
#+begin_src emacs-lisp :lexical t 
(use-package evil-collection
  :ensure (:remotes ("origin"
                      ("fork" :repo "progfolio/evil-collection")))
  :after (evil)
  :config (evil-collection-init)
  :init
  (setq evil-collection-setup-minibuffer nil) ;; связано с (evil-want-minibuffer nil)
  :custom
  (evil-collection-elpaca-want-g-filters nil)
  (evil-collection-ement-want-auto-retro t))
#+end_src
** evil-anzu-mode
#+begin_quote
anzu for evil-mode
https://github.com/emacsorphanage/evil-anzu
#+end_quote

Shows match counts in mode line.
#+begin_src emacs-lisp :lexical t
(use-package evil-anzu
  :after (evil anzu))
#+end_src

** evil-nerd-commenter
#+begin_src emacs-lisp :lexical t 
(use-package evil-nerd-commenter
  :after (evil)
  :commands (evilnc-comment-operator
             evilnc-inner-comment
             evilnc-outer-commenter)
  :init
  (define-key evil-normal-state-map (kbd "gc") 'evilnc-comment-or-uncomment-lines)
  (define-key evil-visual-state-map (kbd "gc") 'evilnc-comment-or-uncomment-lines)
)
#+end_src

** TODO evil-escape
#+begin_src emacs-lisp :lexical t :tangle yes
(use-package evil-escape
:config
(evil-escape-mode))
#+end_src

* TODO Emacs
#+begin_src emacs-lisp :lexical t
(use-feature emacs
  :demand t
  :custom
  (scroll-conservatively 101 "Scroll just enough to bring text into view")
  (enable-recursive-minibuffers t "Allow minibuffer commands in minibuffer")
  (frame-title-format '(buffer-file-name "%f" ("%b"))
                      "Make frame title current file's name.")
  (frame-resize-pixelwise t) ;; fvwm3 

  (find-library-include-other-files nil)
  (indent-tabs-mode nil "Use spaces, not tabs")
  (inhibit-startup-screen t)
  (history-delete-duplicates t "Don't clutter history")
  (pgtk-use-im-context-on-new-connection nil "Prevent GTK from stealing Shift + Space")
  (sentence-end-double-space nil "Double space sentence demarcation breaks sentence navigation in Evil")
  (tab-stop-list (number-sequence 2 120 2))
  (tab-width 2 "Shorter tab widths")
  (column-numbes-mode t);;
  (truncate-lines t) ;; убрать перенос " ↪ " 
  (line-numbers-mode t) ;; строки и колоки(882,44)
  (column-number-mode t)
  (use-short-answers t) ;; yes-no to y-n
  (completion-styles '(flex basic partial-completion emacs22))
  ;; c corfu. если не будет работать. положить в init
  (completion-cycle-threshold 3)
  (tab-always-indent 'complete)
  :init
  (setq locale-coding-system 'utf-8
        coding-system-for-read 'utf-8
        coding-system-for-write 'utf-8)
  (set-terminal-coding-system 'utf-8)
  (set-keyboard-coding-system 'utf-8)
  (set-selection-coding-system 'utf-8)
  (prefer-coding-system 'utf-8)
  ;; don't want ESC as a modifier. 
  (global-set-key (kbd "<escape>") 'keyboard-escape-quit) ;; переделать
  (add-to-list 'auto-mode-alist '("\\.cl\\'" . lisp-mode))
  

  ;; (setq display-buffer-alist
  ;;       `((,(rx bos (or "*Apropos*" "*Help*" "*helpful" "*info*" "*Summary*") (0+ not-newline))
  ;;          (display-buffer-reuse-mode-window display-buffer-below-selected)
  ;;          (window-height . 0.33)
  ;;          (mode apropos-mode help-mode helpful-mode Info-mode Man-mode))))
  
  )
#+end_src
* display-line-numbers
#+begin_src emacs-lisp :lexical t
  ;;(add-hook 'text-mode-hook #'display-line-numbers-mode)
  (add-hook 'prog-mode-hook #'display-line-numbers-mode)
#+end_src
* Which-key
#+begin_src emacs-lisp :lexical t
(use-package which-key
  :demand t
  :init
  (setq which-key-enable-extended-define-key t)
  :config
  (which-key-mode)
  :custom
  (which-key-setup-side-window-bottom)
  (which-key-sort-order 'which-key-key-order-alpha)
  (which-key-side-window-max-width 0.33)
  ;;(which-key-idle-delay 0.2)
  ;;(which-key-idle-delay 1)
  )
#+end_src

* exec-path-from-shell Переменные среды
Как в Doom. 
#+begin_src emacs-lisp :lexical t :tangle yes
;;; Code to replace exec-path-from-shell
;; Need to create file in $HOME/.emacs.d/.local/env
;; use this command to create the file  `printenv > $HOME/.emacs.d/.local/env'
(defconst my-local-dir (concat user-emacs-directory ".local/"))

(defconst my-env-file (concat my-local-dir "env"))

(defun my-load-envvars-file (file &optional noerror)
  "Read and set envvars from FILE.
If NOERROR is non-nil, don't throw an error if the file doesn't exist or is
unreadable. Returns the names of envvars that were changed."
  (if (not (file-readable-p file))
      (unless noerror
        (signal 'file-error (list "Couldn't read envvar file" file)))
    (let (envvars environment)
      (with-temp-buffer
        (save-excursion
          (insert "\n")
          (insert-file-contents file))
        (while (re-search-forward "\n *\\([^#= \n]*\\)=" nil t)
          (push (match-string 1) envvars)
          (push (buffer-substring
                 (match-beginning 1)
                 (1- (or (save-excursion
                           (when (re-search-forward "^\\([^= ]+\\)=" nil t)
                             (line-beginning-position)))
                         (point-max))))
                environment)))
      (when environment
        (setq process-environment
              (append (nreverse environment) process-environment)
              exec-path
              (if (member "PATH" envvars)
                  (append (split-string (getenv "PATH") path-separator t)
                          (list exec-directory))
                exec-path)
              shell-file-name
              (if (member "SHELL" envvars)
                  (or (getenv "SHELL") shell-file-name)
                shell-file-name))
        envvars))))

(when (and (or (display-graphic-p)
               (daemonp))
           (file-exists-p my-env-file))
  (my-load-envvars-file my-env-file))
;;; Code to replace exec-path-from-shell
#+end_src

#+begin_src emacs-lisp :lexical t :tangle no
  (use-package exec-path-from-shell
    :custom (exec-path-from-shell-arguments '("-l"))
    :init (exec-path-from-shell-initialize))
#+end_src

* electric-pair-mode
#+begin_src emacs-lisp :lexical t :tangle yes
(use-feature elec-pair
  :defer t
  :hook (prog-mode . electric-pair-mode)
  ;; :config
  ;; (electric-pair-mode t)
  )
#+end_src

* atomic-chrome
#+begin_src emacs-lisp :lexical t
(use-package atomic-chrome
  :demand t
  :ensure (atomic-chrome :host github :repo "KarimAziev/atomic-chrome")
  :commands (atomic-chrome-start-server)
  :config
  (setq-default atomic-chrome-extension-type-list '(atomic-chrome))
  (atomic-chrome-start-server))
#+end_src

* eshell
#+begin_src emacs-lisp :lexical t 
(use-feature eshell
  :custom
  (eshell-banner-message "")
  :init
  (setq eshell-prompt-regexp "^[^#$\n]*[#$] "
        eshell-prompt-function
        (lambda nil
          (concat
	         "[" (user-login-name) "@" (system-name) " "
	         (if (string= (eshell/pwd) (getenv "HOME"))
	             "~" (eshell/basename (eshell/pwd)))
	         "]"
	         (if (= (user-uid) 0) "# " "$ "))))

  ;;TODO 
  (defun project-eshell-popup (&optional arg)
    "Start Eshell in a pop-up window in the current project's root directory.
If a buffer already exists for running Eshell in the project's root,
switch to it. Otherwise, create a new Eshell buffer.
With \\[universal-argument] prefix arg, create a new Eshell buffer even
if one already exists."
    (interactive "P")
    (let* ((default-directory (project-root (project-current t)))
           (eshell-buffer-name (project-prefixed-buffer-name "eshell"))
           (eshell-buffer (get-buffer eshell-buffer-name))
           (display-buffer-alist
            '(("\\*eshell.*\\*"
               (display-buffer-in-side-window)
               (window-height . 0.3)
               (side . bottom)
               (slot . 0)))))
      (if (and eshell-buffer (not arg))
          (pop-to-buffer eshell-buffer)
        (let ((buf (generate-new-buffer eshell-buffer-name)))
          (pop-to-buffer buf)
          (unless (derived-mode-p 'eshell-mode)
            (eshell-mode))
          buf))))
  
  (add-hook 'eshell-mode-hook (lambda () (setenv "TERM" "xterm-256color")))) 

;; (setq eshell-prompt-function
;;   (lambda ()
;;     (concat
;;      (propertize "┌─[" 'face `(:foreground "#2aa198"))
;;      (propertize (user-login-name) 'face `(:foreground "#dc322f"))
;;      (propertize "@" 'face `(:foreground "#2aa198"))
;;      (propertize (system-name) 'face `(:foreground "#268bd2"))
;;      (propertize "]──[" 'face `(:foreground "#2aa198"))
;;      (propertize (format-time-string "%H:%M" (current-time)) 'face `(:foreground "#b58900"))
;;      (propertize "]──[" 'face `(:foreground "#2aa198"))
;;      (propertize (concat (eshell/pwd)) 'face `(:foreground "#93a1a1"))
;;      (propertize "]\n" 'face `(:foreground "#2aa198"))
;;      (propertize "└─>" 'face `(:foreground "#2aa198"))
;;      (propertize (if (boundp 'venv-current-name)
;;             (concat " (" venv-current-name ")")
;;           "")
;;         'face `(:foreground "#00dc00"))
;;      (propertize (if (= (user-uid) 0) " # " " $ ") 'face `(:foreground "#2aa198"))
;;      ))))
#+end_src

#+begin_src emacs-lisp :lexical t 
    ;; (setq eshell-prompt-function
    ;;   (lambda ()
    ;;     (concat
    ;;      (propertize "┌─[" 'face `(:foreground "#2aa198"))
    ;;      (propertize (user-login-name) 'face `(:foreground "#dc322f"))
    ;;      (propertize "@" 'face `(:foreground "#2aa198"))
    ;;      (propertize (system-name) 'face `(:foreground "#268bd2"))
    ;;      (propertize "]──[" 'face `(:foreground "#2aa198"))
    ;;      (propertize (format-time-string "%H:%M" (current-time)) 'face `(:foreground "#b58900"))
    ;;      (propertize "]──[" 'face `(:foreground "#2aa198"))
    ;;      (propertize (concat (eshell/pwd)) 'face `(:foreground "#93a1a1"))
    ;;      (propertize "]\n" 'face `(:foreground "#2aa198"))
    ;;      (propertize "└─>" 'face `(:foreground "#2aa198"))
    ;;      (propertize (if venv-current-name (concat " (" venv-current-name ")")  "") 'face `(:foreground "#00dc00"))
    ;;      (propertize (if (= (user-uid) 0) " # " " $ ") 'face `(:foreground "#2aa198"))
    ;;      )))
#+end_src
* eshell-toggle
[[https://github.com/4DA/eshell-toggle/blob/master/eshell-toggle.el][eshell-toggle/eshell-toggle.el at master · 4DA/eshell-toggle · GitHub]]
* TODO Настройка темы modus
Посмотреть  [[https://github.com/angrybacon/dotemacs/blob/345d8b71f6c8bb9c59bfc21cdde6859451361929/lisp/zenmelt/zenmelt-theme.el#L440][dotemacs/lisp/zenmelt/zenmelt-theme.el at 345d8b71f6c8bb9c59bfc21cdde68594513...]]
** treesit

#+begin_src emacs-lisp :lexical t
;; Adapted from: rougier/nano-emacs
(defun +what-faces (pos)
  "Get the font faces at POS."
  (interactive "d")
  (let ((faces (remq nil
                     (list
                      (get-char-property pos 'read-face-name)
                      (get-char-property pos 'face)
                      (plist-get (text-properties-at pos) 'face)))))
    (message "Faces: %s" faces)))
#+end_src
** тема
#+begin_src emacs-lisp :lexical t :tangle yes
(use-package modus-themes
  :config 
  (setq modus-themes-custom-auto-reload nil
      modus-themes-bold-constructs nil
      modus-themes-mixed-fonts t 
      modus-themes-italic-constructs t
      modus-themes-prompts '(bold intense)
      modus-themes-completions '((t . (extrabold)))
      modus-themes-headings
      '((0 . (variable-pitch 1))
        (t . (variable-pitch 1)) 

    ))
    ;;fonts
    (set-face-attribute 'default nil :height 190)
    (set-face-attribute 'variable-pitch nil :family "IBM Plex Serif" :height 1.0 :weight 'medium)
    (set-face-attribute 'fixed-pitch nil :family (face-attribute 'default :family))

    (setq modus-themes-common-palette-overrides
          '(
          (fringe unspecified)
          (border-mode-line-active unspecified)
          (border-mode-line-inactive unspecified)
          ))

    ;;Dark 
    (setq modus-vivendi-palette-overrides
        '((bg-main  "#1e1f22");;idea
          (fg-main "#bcbec4")
          (constant "#bcbec4")
          (fnname "#57aaf7")
          (keyword "#fa8072") ;; light salmon 
          (string "#6AAB73")
          (type "#BCBEC4")
          (variable "#bcbec4")
          ;;rainbow-delimiters
          (rainbow-0 "#E8BA36")
          (rainbow-1 "#54A857")
          (rainbow-2 "#359FF4")
          (rainbow-3 "#6E7ED9")
          (rainbow-4 "#179387")
          (rainbow-5 "#A5BE00")
          (rainbow-6 "#005FA3")
          (rainbow-7 "#DB7100")
          (rainbow-8 "#FFC666")
          (rainbow-9 "#38FF91")
          ))
    ;; TODO Light
    (setq modus-operandi-palette-overrides
        '(
          (bg-main  "#f2f3f4")
          ;;(fg-main "#bcbec4")
          ))
    ;; Make line numbers less intense
;; (setq modus-themes-common-palette-overrides
;;       '((fg-line-number-inactive "gray50")
;;         (fg-line-number-active fg-main)
;;         (bg-line-number-inactive unspecified)
;;         (bg-line-number-active unspecified)))
;;TODO
(setq modus-themes-vivendi-palette-overrides
      '((fg-line-number-inactive "gray50")
        (fg-line-number-active fg-main)
        (bg-line-number-inactive unspecified)
        (bg-line-number-active unspecified)))
;;TODO
(defun my-modus-themes-invisible-dividers (&rest _)
  "Make window dividers for THEME invisible."
  (let ((bg (face-background 'default)))
    (custom-set-faces
     `(fringe ((t :background ,bg :foreground ,bg)))
     `(window-divider ((t :background ,bg :foreground ,bg)))
     `(window-divider-first-pixel ((t :background ,bg :foreground ,bg)))
     `(window-divider-last-pixel ((t :background ,bg :foreground ,bg))))))

(add-hook 'enable-theme-functions #'my-modus-themes-invisible-dividers)

    (load-theme 'modus-vivendi t))

    ;;  (setq modus-themes-common-palette-overrides '((constant "#bcbec4")))
        ;;;;; font-lock
    ;; `(font-lock-builtin-face ((,c :inherit modus-themes-bold :foreground ,builtin)))
    ;; `(font-lock-comment-delimiter-face ((,c :inherit font-lock-comment-face)))
    ;; `(font-lock-comment-face ((,c :inherit modus-themes-slant :foreground ,comment)))
    ;; `(font-lock-constant-face ((,c :foreground ,constant)))
    ;; `(font-lock-doc-face ((,c :inherit modus-themes-slant :foreground ,docstring)))
    ;; `(font-lock-doc-markup-face ((,c :inherit modus-themes-slant :foreground ,docmarkup)))
    ;; `(font-lock-function-name-face ((,c :foreground ,fnname)))
    ;; `(font-lock-keyword-face ((,c :inherit modus-themes-bold :foreground ,keyword)))
    ;; `(font-lock-negation-char-face ((,c :inherit error)))
    ;; `(font-lock-preprocessor-face ((,c :foreground ,preprocessor)))
    ;; `(font-lock-regexp-grouping-backslash ((,c :inherit modus-themes-bold :foreground ,rx-backslash)))
    ;; `(font-lock-regexp-grouping-construct ((,c :inherit modus-themes-bold :foreground ,rx-construct)))
    ;; `(font-lock-string-face ((,c :foreground ,string)))
    ;; `(font-lock-type-face ((,c :inherit modus-themes-bold :foreground ,type)))
    ;; `(font-lock-variable-name-face ((,c :foreground ,variable)))
    ;; `(font-lock-warning-face ((,c :inherit modus-themes-bold :foreground ,warning)))
#+end_src
* dired
#+begin_src emacs-lisp :lexical t
(use-feature dired
  :commands dired-jump ;; или просто dired ?
  :custom
  (dired-kill-when-opening-new-dired-buffer t)
  ;; (dired-omit-files "\\(?:\\.+[^z-a]*\\)")
  ;; (dired-clean-up-buffers-too nil) х3 зачет nil
  (dired-dwim-target t)
  (dired-mouse-drag-files t)
  (dired-recursive-deletes 'always)
  (dired-recursive-copies 'always)
  (dired-hide-details-hide-information-lines nil)
  (dired-hide-details-hide-symlink-targets nil) 
  (dired-omit-mode t nil) 
  (dired-omit-verbose nil)
  :hook (dired-mode-hook . dired-hide-details-mode)
  :config
  ;;(setq dired-omit-files (rx (seq bol ".")))
  (let ((args (list "-ahl" "-v" "--group-directories-first")))
    (when (featurep :system 'bsd)
      (if-let* (gls (executable-find "gls"))
          (setq insert-directory-program gls)
        (setq args (list (car args)))))
    (setq dired-listing-switches (string-join args " ")))
)
#+end_src
** diredfl
Цвета темы для dired
#+begin_src emacs-lisp :lexical t
(use-package diredfl
  :hook (dired-mode . diredfl-mode))
#+end_src
** TODO dired-rsync

#+begin_src emacs-lisp :lexical t :tangle no
(use-package dired-rsync
  :defer t
  :general (dired-mode-map "C-c C-r" #'dired-rsync))
#+end_src
** nerd-icons-dired
Не получается настроить defun
#+begin_src emacs-lisp :lexical t
(use-package nerd-icons-dired
  :hook (dired-mode . nerd-icons-dired-mode)
;;   :config
;;   (defun +dired-disable-icons-in-wdired-mode-a (&rest _)
;;     "Disable nerd-icons-dired-mode in wdired-mode."
;;     (when (eq major-mode 'wdired-mode)
;;       (setq-local +wdired-icons-enabled (if nerd-icons-dired-mode 1 -1))
;;       (when nerd-icons-dired-mode
;;         (nerd-icons-dired-mode -1))))

;;   (defun +dired-restore-icons-after-wdired-mode-a (&rest _)
;;     "Restore nerd-icons-dired-mode after leaving wdired-mode."
;;     (when (eq major-mode 'dired-mode)
;;       (when (and nerd-icons-dired-mode (boundp '+wdired-icons-enabled))
;;         (nerd-icons-dired-mode +wdired-icons-enabled))))
;; (advice-add 'wdired-change-to-wdired-mode :before #'+dired-disable-icons-in-wdired-mode-a)
;; (advice-add 'wdired-change-to-dired-mode :after #'+dired-restore-icons-after-wdired-mode-a)
)
#+end_src
** TODO fd-dired
Зачем ?
#+begin_src emacs-lisp :lexical t :tangle no
(use-package! fd-dired
  :when doom-projectile-fd-binary
  :defer t
  :init
  (global-set-key [remap find-dired] #'fd-dired)
  (set-popup-rule! "^\\*F\\(?:d\\|ind\\)\\*$" :ignore t))
#+end_src
** TODO dired-aux
Как будто не надо. 
#+begin_src emacs-lisp :lexical t
(use-feature dired-aux
  :defer t)
#+end_src
** dired-x
#+begin_src emacs-lisp :lexical t 
(use-feature dired-x
 :after dired
 :hook (dired-mode . dired-omit-mode))
#+end_src
** dired-sidebar
Хуйня
#+begin_src emacs-lisp :lexical t :tangle no 
(use-package dired-sidebar
  :bind (("C-x C-n" . dired-sidebar-toggle-sidebar))
  :commands (dired-sidebar-toggle-sidebar)
  :init
  (add-hook 'dired-sidebar-mode-hook
            (lambda ()
              (unless (file-remote-p default-directory)
                (auto-revert-mode))))
  :config
  (push 'toggle-window-split dired-sidebar-toggle-hidden-commands)
  (push 'rotate-windows dired-sidebar-toggle-hidden-commands)

  ;;(setq dired-sidebar-subtree-line-prefix "__")
  (setq dired-sidebar-subtree-line-prefix "  ")
  (setq dired-sidebar-theme 'nerd)
  (setq dired-sidebar-use-term-integration t)
  (setq dired-sidebar-use-custom-font t))

#+end_src

* docker
#+begin_src emacs-lisp :lexical t
(use-package docker
  :defer t)
#+end_src
* docker-compose-mode
#+begin_src emacs-lisp :lexical t
(use-package docker-compose-mode
  :mode "docker-compose.*\.yml\\'")
#+end_src
* dockerfile-mode
#+begin_src emacs-lisp :lexical t
(use-package dockerfile-mode
  :mode "Dockerfile[a-zA-Z.-]*\\'")
#+end_src
* TODO Настройка скролла
[[https://github.com/Lovesan/.emacs.d/blob/master/lisp/lvsn-commons.el]] потом попробовать.
[[https://github.com/MatthewZMD/.emacs.d/blob/7c0269d77ba4b99186143ebdd9afff04ce69580b/elisp/init-scroll.el#L42]]
scroll-conservatively  101 или 10000 ? 
#+begin_src emacs-lisp :lexical t 
(when (display-graphic-p)
  (setq mouse-wheel-scroll-amount '(1 ((shift) . hscroll))
        mouse-wheel-scroll-amount-horizontal 1
        mouse-wheel-progressive-speed nil))
(setq scroll-step 1
      scroll-margin 1 ;; default 0
      auto-window-vscroll nil
      scroll-preserve-screen-position t)
(pixel-scroll-precision-mode t)

#+end_src
Работает но только в режиме Emacs 
#+begin_src emacs-lisp :lexical t  :tangle no
  (use-package iscroll
    :diminish
    :hook
    (image-mode . iscroll-mode)
    (org-mode . iscroll-mode))
#+end_src
Работает но требует донастройки
#+begin_src emacs-lisp :lexical t :tangle no
  (use-package org-sliced-images
    :ensure (org-sliced-images :host github :repo "jcfk/org-sliced-images" :files ("org-sliced-images.el"))
    :config 
    (defalias 'org-remove-inline-images #'org-sliced-images-remove-inline-images)
    (defalias 'org-toggle-inline-images #'org-sliced-images-toggle-inline-images)
    (defalias 'org-display-inline-images #'org-sliced-images-display-inline-images))
#+end_src

Пример iscroll который должнен работать с evil. 
#+begin_src emacs-lisp :lexical t :tangle no
(use-package iscroll
  :defer t
  :commands (iscroll-mode)
  :config
  (evil-define-motion iscroll-evil-next-line (count)
    "Move the cursor COUNT lines down."
    :type line
    (let (line-move-visual)
      (iscroll-evil-line-move (or count 1))))

  (evil-define-motion iscroll-evil-previous-line (count)
    "Move the cursor COUNT lines up."
    :type line
    (let (line-move-visual)
      (iscroll-evil-line-move (- (or count 1)))))

  (evil-define-motion iscroll-evil-next-visual-line (count)
    "Move the cursor COUNT screen lines down."
    :type exclusive
    (let ((line-move-visual t))
      (iscroll-evil-line-move (or count 1))))

  (evil-define-motion iscroll-evil-previous-visual-line (count)
    "Move the cursor COUNT screen lines up."
    :type exclusive
    (let ((line-move-visual t))
      (iscroll-evil-line-move (- (or count 1)))))

  (defun iscroll-evil-line-move (count &optional noerror)
    "A wrapper for line motions which conserves the column.
Signals an error at buffer boundaries unless NOERROR is non-nil."
    (cond
     (noerror
      (condition-case nil
          (evil-line-move count)
        (error nil)))
     (t
      (evil-signal-without-movement
        (setq this-command (if (>= count 0)
                               #'iscroll-next-line
                             #'iscroll-previous-line))
        (let ((opoint (point)))
          (condition-case err
              (with-no-warnings
                (funcall this-command (abs count)))
            ((beginning-of-buffer end-of-buffer)
             (let ((col (or goal-column
                            (if (consp temporary-goal-column)
                                (car temporary-goal-column)
                              temporary-goal-column))))
               (if line-move-visual
                   (vertical-motion (cons col 0))
                 (line-move-finish col opoint (< count 0)))
               ;; Maybe we should just `ding'?
               (signal (car err) (cdr err))))))))))

  (define-advice iscroll-mode (:after (&optional arg) yang)
    "Add evil keybinings for iscroll."
    (if iscroll-mode
        (progn
          (global-set-key [remap evil-next-line] #'iscroll-evil-next-line)
          (global-set-key [remap evil-previous-line] #'iscroll-evil-previous-line)
          (global-set-key [remap evil-next-visual-line] #'iscroll-evil-next-visual-line)
          (global-set-key [remap evil-previous-visual-line] #'iscroll-evil-previous-visual-line))
      (global-set-key [remap evil-next-line] nil)
      (global-set-key [remap evil-previous-line] nil)
      (global-set-key [remap evil-next-visual-line] nil)
      (global-set-key [remap evil-previous-visual-line] nil))))
#+end_src
* auto-fill-mode
#+begin_src emacs-lisp :lexical t
(use-feature simple
  :general
  (+general-global-toggle
    "f" 'auto-fill-mode)
  :custom
  (eval-expression-debug-on-error nil)
  (fill-column 80 "Wrap at 80 columns."))
#+end_src
* TODO benchmark
#+begin_src emacs-lisp :lexical t :tangle no
(use-package benchmark-init
  :config
  ;; To disable collection of benchmark data after init is done.
  (add-hook 'after-init-hook 'benchmark-init/deactivate))
#+end_src
* popper
#+begin_src emacs-lisp :lexical t :tangle yes
(use-package popper
  :bind (("C-`"   . popper-toggle)
         ;; ("M-`"   . popper-cycle)
         ("M-`"   . popper-kill-latest-popup)
         ("C-M-`" . popper-toggle-type))
  :init
  (setq popper-reference-buffers
        '("\\*Messages\\*"
          "Output\\*$"
          "\\*Async Shell Command\\*"
          "\\*eldoc\\*"
          "\\*compilation\\*"
          "\\*Warnings\\*"
          "^\\*eshell.*\\*.*$" eshell-mode
          "^\\*shell.*\\*.*$"  shell-mode
          "^\\*terminal.*\\*.*$" term-mode
          "^\\*vterm.*\\*.*$"  vterm-mode

          helpful-mode
          help-mode
          flymake-diagnostics-buffer-mode
          compilation-mode))
  (popper-mode +1)
  (popper-echo-mode +1))
#+end_src
* popper пример
#+begin_src emacs-lisp :lexical t :tangle no
(use-package popper
  :defines popper-echo-dispatch-actions
  :commands popper-group-by-directory
  ;; :bind (:map popper-mode-map
  ;;             ("s-`" . popper-toggle)
  ;;             ("s-o"   . popper-cycle)
  ;;             ("q" . popper-kill-latest-popup)
  ;;             ("M-`" . popper-toggle-type))
  :hook (emacs-startup . popper-mode)
  :init
  (setq popper-reference-buffers
        '("\\*Messages\\*"
          "Output\\*$" "\\*Pp Eval Output\\*$"
          "\\*Compile-Log\\*"
          "\\*Completions\\*"
          "\\*Warnings\\*"
          "\\*Flymake diagnostics.*\\*"
          "\\*Async Shell Command\\*"
          "\\*Apropos\\*"
          "\\*Backtrace\\*"
          "\\*prodigy\\*"
          "\\*Calendar\\*"
          "\\*Embark Actions\\*"
          "\\*Finder\\*"
          "\\*Kill Ring\\*"
          "\\*Embark Export:.*\\*"
          "\\*Edit Annotation.*\\*"
          "\\*Flutter\\*"
          bookmark-bmenu-mode
          lsp-bridge-ref-mode
          comint-mode
          compilation-mode
          help-mode helpful-mode
          tabulated-list-mode
          Buffer-menu-mode
          occur-mode
          gnus-article-mode devdocs-mode
          grep-mode occur-mode rg-mode deadgrep-mode ag-mode pt-mode
          ivy-occur-mode ivy-occur-grep-mode
          process-menu-mode list-environment-mode cargo-process-mode
          youdao-dictionary-mode osx-dictionary-mode fanyi-mode

          "^\\*eshell.*\\*.*$" eshell-mode
          "^\\*shell.*\\*.*$"  shell-mode
          "^\\*terminal.*\\*.*$" term-mode
          "^\\*vterm.*\\*.*$"  vterm-mode

          "\\*DAP Templates\\*$" dap-server-log-mode
          "\\*ELP Profiling Restuls\\*" profiler-report-mode
          "\\*Flycheck errors\\*$" " \\*Flycheck checker\\*$"
          "\\*Paradox Report\\*$" "\\*package update results\\*$" "\\*Package-Lint\\*$"
          "\\*[Wo]*Man.*\\*$"
          "\\*ert\\*$" overseer-buffer-mode
          "\\*gud-debug\\*$"
          "\\*lsp-help\\*$" "\\*lsp session\\*$"
          "\\*quickrun\\*$"
          "\\*tldr\\*$"
          "\\*vc-.*\\*$"
          "\\*eldoc\\*"
          "^\\*elfeed-entry\\*$"
          "^\\*macro expansion\\**"

          "\\*Agenda Commands\\*" "\\*Org Select\\*" "\\*Capture\\*" "^CAPTURE-.*\\.org*"
          "\\*Gofmt Errors\\*$" "\\*Go Test\\*$" godoc-mode
          "\\*docker-containers\\*" "\\*docker-images\\*" "\\*docker-networks\\*" "\\*docker-volumes\\*"
          "\\*prolog\\*" inferior-python-mode inf-ruby-mode swift-repl-mode
          "\\*rustfmt\\*$" rustic-compilation-mode rustic-cargo-clippy-mode
          rustic-cargo-outdated-mode rustic-cargo-test-moed))

  ;; (when (display-grayscale-p)
  ;;   (setq popper-mode-line
  ;;         '(:eval
  ;;           (concat
  ;;            (propertize " " 'face 'mode-line-emphasis)
  ;;            (all-the-icons-octicon "pin" :height 0.9 :v-adjust 0.0 :face 'mode-line-emphasis)
  ;;            (propertize " " 'face 'mode-line-emphasis)))))

  (setq popper-echo-dispatch-actions t)
  (setq popper-group-function nil)
  :config
  (popper-echo-mode 1)

  (with-no-warnings
    (defun my-popper-fit-window-height (win)
      "Determine the height of popup window WIN by fitting it to the buffer's content."
      (fit-window-to-buffer
       win
       (floor (frame-height) 3)
       (floor (frame-height) 3)))
    (setq popper-window-height #'my-popper-fit-window-height)

    (defun popper-close-window-hack (&rest _)
      "Close popper window via `C-g'."
      ;; `C-g' can deactivate region
      (when (and (called-interactively-p 'interactive)
                 (not (region-active-p))
                 popper-open-popup-alist)
        (let ((window (caar popper-open-popup-alist)))
          (when (window-live-p window)
            (delete-window window)))))
    (advice-add #'keyboard-quit :before #'popper-close-window-hack)))
#+end_src
* auto-revert 
#+begin_src emacs-lisp :lexical t
(use-feature autorevert
  :defer 2
  :custom
  (auto-revert-interval 0.01 "Instantaneously revert")
  :config
  (global-auto-revert-mode t))
#+end_src
* anki-editor
#+begin_src emacs-lisp :lexical t
(use-package anki-editor
  :ensure (anki-editor :host github :repo "orgtre/anki-editor")
  ;;orgtre/anki-editor
  ;;anki-editor/anki-editor
  :after (org)
  :commands anki-editor-mode
  :bind (:map org-mode-map
              ("<f12>" . anki-editor-cloze-region-auto-incr)
              ("<f11>" . anki-editor-cloze-region-dont-incr)
              ("<f10>" . anki-editor-reset-cloze-number)
              ("<f9>"  . anki-editor-push-tree))
  :hook (org-capture-after-finalize . anki-editor-reset-cloze-number) ; Reset cloze-number after each capture.
  :custom (anki-editor-latex-style 'mathjax)
  :config
  (setq anki-editor-create-decks t ;; Allow anki-editor to create a new deck if it doesn't exist
        anki-editor-org-tags-as-anki-tags t)

  (defun anki-editor-cloze-region-auto-incr (&optional arg)
    "Cloze region without hint and increase card number."
    (interactive)
    (anki-editor-cloze-region my-anki-editor-cloze-number "")
    (setq my-anki-editor-cloze-number (1+ my-anki-editor-cloze-number))
    (forward-sexp))
  (defun anki-editor-cloze-region-dont-incr (&optional arg)
    "Cloze region without hint using the previous card number."
    (interactive)
    (anki-editor-cloze-region (1- my-anki-editor-cloze-number) "")
    (forward-sexp))
  (defun anki-editor-reset-cloze-number (&optional arg)
    "Reset cloze number to ARG or 1"
    (interactive)
    (setq my-anki-editor-cloze-number (or arg 1)))
  (defun anki-editor-push-tree ()
    "Push all notes under a tree."
    (interactive)
    (anki-editor-push-notes '(4))
    (anki-editor-reset-cloze-number))
  ;; Initialize
  (anki-editor-reset-cloze-number))
#+end_src
* anki-org
#+begin_src emacs-lisp :lexical t
(use-package ankiorg
  :ensure (ankiorg :host github :repo "orgtre/ankiorg")
  :defer t
  :commands
  ankiorg-pull-notes
  ankiorg-buffer-get-media-files
  ankiorg-pull-tags
  :custom
  (ankiorg-sql-database
   "/home/snake/.local/share/Anki2/snake/collection.anki2")
  (ankiorg-media-directory
   "/home/snake/.local/share/Anki2/snake/collection.media/"))

#+end_src
* TODO smart-backspace
#+begin_src emacs-lisp :lexical t :tangle no
(defun smart-backspace (n &optional killflag)
  "This function provides intellij like backspace.
Delete the backword-char usually and delete whitespace
to previous line indentation if it's start of line.
If a prefix argument is giben, delete the following N characters.
Optianal second arg KILLFLAG non-nil means to kill (save in killring)
instead of delete. Interactively, N is the prefix arg, and KILLFLAG
is set if N was explicitly specified."
  (interactive "p\nP")
  (let* ((current (point))
         (beginning (save-excursion
                      (beginning-of-line)
                      (point))))
    (if (string-match "^[ \t]*$" (buffer-substring beginning current))
        (progn
          (kill-line 0)
          (delete-char (- n) killflag)
          (indent-according-to-mode))
      (delete-char (- n) killflag))))
(define-key evil-insert-state-map [?\C-?] 'smart-backspace)
#+end_src

#+begin_src emacs-lisp :lexical t
(use-package smart-backspace
  :bind ("<C-M-backspace>" . smart-backspace))

#+end_src
* sqlite3
#+begin_src emacs-lisp :lexical t
(use-package sqlite3
  :ensure (sqlite3 :host github :repo "pekingduck/emacs-sqlite3-api")
  :defer t)

#+end_src
* leetcode
#+begin_src emacs-lisp :lexical t
(use-package leetcode
  :ensure (leetcode :host github :repo "kaiwk/leetcode.el" :files ("leetcode.el"))
  :defer t
  :custom
  (leetcode-prefer-language "java"))

#+end_src

* elcord
[[https://github.com/yqrashawn/yqdotfiles/blob/1634092b80933ecd94018074847e2aaf35279d69/.doom.d/visual.el#L45][yqrashawn]] фикс таймера
#+begin_src emacs-lisp :lexical t
(use-package elcord
  ;;:commands elcord 
  :config
  (setq elcord-use-major-mode-as-main-icon t)
  (setq elcord-display-buffer-details nil)
  (setq elcord-idle-message "Thinking 🤔")
  (setq elcord-quiet t)
  (elcord-mode))
#+end_src

* telega
#+begin_src emacs-lisp :lexical t
(use-package telega
  :commands (telega)
  :defer t)
#+end_src

* bookmark
#+begin_src emacs-lisp :lexical t
(use-feature bookmark
  :custom (bookmark-fontify nil)
  :general
  (+general-global-bookmark
    "j" 'bookmark-jump
    "s" 'bookmark-set
    "r" 'bookmark-rename))
#+end_src
* buttercup
#+begin_quote
Buttercup is a behavior-driven development framework for testing Emacs Lisp code.

https://github.com/jorgenschaefer/emacs-buttercup
#+end_quote
#+begin_src emacs-lisp :lexical t
(use-package buttercup
  :commands (buttercup-run-at-point))
#+end_src
* compile
#+begin_src emacs-lisp :lexical t
(use-feature compile
  :commands (compile recompile)
  :custom
  (compilation-scroll-output 'first-error)
  (compilation-always-kill t)
  (compilation-ask-about-save nil);;autosave + compile 
  :config

  (defun +compilation-colorize ()
    "Colorize from `compilation-filter-start' to `point'."
    (require 'ansi-color)
    (let ((inhibit-read-only t))
      (ansi-color-apply-on-region (point-min) (point-max))))
  (add-hook 'compilation-filter-hook #'+compilation-colorize))
#+end_src

* ediff

#+begin_src emacs-lisp :lexical t
(use-feature ediff
  :hook(;; show org ediffs unfolded
        (ediff-prepare-buffer . outline-show-all)
        ;; restore window layout when done
        (ediff-quit . winner-undo))
  :config
  (setq ediff-window-setup-function 'ediff-setup-windows-plain
        ediff-split-window-function 'split-window-horizontally
        ediff-merge-split-window-function 'split-window-horizontally))
  
#+end_src
* anzu 
#+begin_quote
anzu.el provides a minor mode which displays 'current match/total
matches' in the mode-line in various search modes.  This makes it
easy to understand how many matches there are in the current buffer
for your search query.
#+end_quote

#+begin_src emacs-lisp :lexical t
(use-package anzu
  :defer 10
  :config (global-anzu-mode))
#+end_src

* Бекапы и Автосейвы 
#+begin_src emacs-lisp :lexical t :tangle yes
(use-feature files
  ;;:hook
  ;;(before-save . delete-trailing-whitespace)
  :config
  ;; source: http://steve.yegge.googlepages.com/my-dot-emacs-file
  (defun rename-file-and-buffer (new-name)
    "Renames both current buffer and file it's visiting to NEW-NAME."
    (interactive "sNew name: ")
    (let ((name (buffer-name))
          (filename (buffer-file-name)))
      (if (not filename)
          (message "Buffer '%s' is not visiting a file." name)
        (if (get-buffer new-name)
            (message "A buffer named '%s' already exists." new-name)
          (progn
            (rename-file filename new-name 1)
            (rename-buffer new-name)
            (set-visited-file-name new-name)
            (set-buffer-modified-p nil))))))
  :custom
  (require-final-newline t "Automatically add newline at end of file")
  (backup-by-copying t)
  (backup-directory-alist `((".*" . ,(expand-file-name
                                      (concat user-emacs-directory "backups"))))
                          "Keep backups in their own directory")
  (auto-save-file-name-transforms `((".*" ,(concat user-emacs-directory "autosaves/") t)))
  (delete-old-versions t)
  (kept-new-versions 10)
  (kept-old-versions 5)
  (version-control t)
  (safe-local-variable-values
   '((eval load-file "./init-dev.el")
     (org-clean-refile-inherit-tags))
   "Store safe local variables here instead of in emacs-custom.el"))
#+end_src

* autosave. 
[[https://github.com/zendo/nsworld/blob/fc5b7bf36df24e97eab45f27bcd18b20d05191bd/dotfiles/emacs/elisp/ee-backup.el#L26][nsworld/dotfiles/emacs/elisp/ee-backup.el at fc5b7bf36df24e97eab45f27bcd18b20...]]
#+begin_src emacs-lisp :lexical t
(auto-save-visited-mode 1)
;; (setq auto-save-visited-interval 15) ;default is 5s
(add-function :after after-focus-change-function (lambda () (save-some-buffers t)))
#+end_src

* save-place
#+begin_src emacs-lisp :lexical t
;; Temp files (save-place, recenf, undo-tree)
(defconst my-temp (expand-file-name "my-temp" user-emacs-directory))
(unless (file-exists-p my-temp)
  (make-directory my-temp))
(setq save-place-file (expand-file-name "saveplace" my-temp))
(save-place-mode 1)
#+end_src

* undo-fu
#+begin_src emacs-lisp :lexical t
(use-package undo-fu
  :defer t)
#+end_src
* undo-fu-session
#+begin_src emacs-lisp :lexical t
(use-package undo-fu-session
  :defer t
  :custom
  (undo-fu-session-incompatible-files '("/COMMIT_EDITMSG\\'" "/git-rebase-todo\\'"))
  :config
  (global-undo-fu-session-mode 1))
  #+end_src
  
* undo-tree C-x u
#+begin_src emacs-lisp :lexical t
(use-package vundo
  :bind (("C-x u" . vundo))
  :config
  (setq vundo-glyph-alist vundo-unicode-symbols)
  (setq vundo-roll-back-on-quit nil))
  #+end_src
* savehist истории минибуфера 
#+begin_src emacs-lisp :lexical t
(use-feature savehist
  :defer 1
  :config
  (savehist-mode 1))
#+end_src
* Мой modeline
[[https://gist.github.com/clemera/8f6bdeffaf3495c98a070e50dc65acbc][mode-line+ · GitHub]]
#+begin_src emacs-lisp :lexical t
(defface evil-state-face
  '((t (:weight bold)))
  "Bold"
  )

(defface evil-normal-face
    '((t (:inherit evil-state-face 
        :background "#ff5f5f"
        :foreground "white")))
    "White")
(defface evil-emacs-face
  '((t (:inherit evil-state-face
			:background "#3366ff"
			:foreground "white")))
  "The evil emacs state "
  )

(defface evil-insert-face
  '((t (:inherit evil-state-face
			:background "#3399ff"
			:foreground "white")))
  "The evil insert state"
  )

(defface evil-replace-face
  '((t (:inherit evil-state-face
			:background "#33ff99"
			:foreground "black")))
  "The evil replace state"
  )

(defface evil-operator-face
  '((t (:inherit evil-state-face
			:background "pink"
			:foreground "black")))
  "The evil operator state"
  )

(defface evil-motion-face
  '((t (:inherit evil-state-face
			:background "purple"
			:foreground "white")))
  "The evil motion state"
  )

(defface evil-visual-face
  '((t (:inherit (region evil-state-face))))
  "The evil visual state"
  )

(defun my-evil nil
     (let ((state (if (bound-and-true-p evil-state)
                     (symbol-name evil-state)
                    " ")))
     (propertize (concat " " (upcase state) " ") 'face (intern (format "evil-%s-face" state)))))

(setq-default mode-line-format '((:eval (my-evil))
    ""
     ("%e" mode-line-front-space
     (:propertize
      ("" mode-line-mule-info mode-line-client mode-line-modified mode-line-remote)
      display (min-width (5.0)))
     mode-line-frame-identification
     mode-line-buffer-identification "   "
     mode-line-position
     (project-mode-line project-mode-line-format) (vc-mode vc-mode) "  "
     minions-mode-line-modes
     mode-line-misc-info
     mode-line-frame-identification
     mode-line-end-spaces)))

#+end_src

** winum
#+begin_src emacs-lisp :lexical t :tangle no
(use-package winum
  :init
  (defun +evil-mode-line-faces ()
    (if (not (fboundp 'evil-mode))
        'winum-face
      (cond
       ((evil-emacs-state-p)    '((bold :background "white" :foreground "black")))
       ((evil-insert-state-p)   '((bold :background "white" :foreground "black")))
       ((evil-replace-state-p)  '((bold :background "white" :foreground "black")))
       ((evil-motion-state-p)   '((bold :background "white" :foreground "black")))
       ((evil-visual-state-p)   '((bold :background "white" :foreground "black")))
       ((evil-operator-state-p) '((bold :background "white" :foreground "black")))
       (t ;;'((bold :background "DarkGoldenrod2" :foreground "black")) 
        '((bold :inherit mode-line))
        )
       )))

  (setq winum--mode-line-segment
        '(:eval
          (propertize (format winum-format (int-to-string (winum-get-number)))
                      'face (+evil-mode-line-faces))))
  (winum-mode 1))

#+end_src

* minions
Скрывает все моды. 
#+begin_src emacs-lisp :lexical t
(use-package minions
  :custom
  (minions-prominent-modes '(flymake-mode))
  :config
  (setq minions-mode-line-lighter "  "
        minions-mode-line-delimiters '("" . ""))
  
  (minions-mode 1))
#+end_src

* TODO ibuffer
* reverse-im 
Русская раскладка
#+begin_src emacs-lisp :lexical t :tangle yes
(use-package reverse-im
  :defer 5
  ;;:after (general evil)
  :custom
  (reverse-im-input-methods '("russian-computer"))
  :config
  (reverse-im-mode t))
#+end_src
* TODO logview
#+begin_src emacs-lisp :lexical t 
(use-package logview
  :defer t
  ;:custom
  ;; (logview-views-file (concat minemacs-local-dir "logview-views.el"))
  ;; (logview-cache-filename (concat minemacs-cache-dir "logview-cache.el")))
  )

#+end_src

* TODO vertico

#+begin_src emacs-lisp :lexical t
(use-package vertico
  :demand t
  :custom (vertico-cycle t)
  ;;:general
  ;;        (   "C-j" 'vertico-next
  ;;           "C-k" 'vertico-previous
  ;;           "<escape>" #'minibuffer-keyboard-quit 
  ;;           "M-<backspace>" 'vertico-directory-delete-word)

  ;; (:keymaps 'vertico-map
  ;;           "C-j" 'vertico-next
  ;;           "C-k" 'vertico-previous
  ;;           "<escape>" 'minibuffer-keyboard-quit 
  ;;           "M-<backspace>" 'vertico-directory-delete-word
  ;;           )
  ;; (general-define-key :states '(normal) :keymaps 'vertico-map
  ;;                      (kbd "<escape>") #'minibuffer-keyboard-quit
  ;;                      )
  ;; (global-leader
  ;;   :keymaps '(vertico-map)
  ;;   "<escape>" 'minibuffer-keyboard-quit)


  :config
  (setf (car vertico-multiline) "\n") ;; don't replace newlines
  (vertico-mode)
  ;; в офф доках такое есть
  ;; (setq minibuffer-prompt-properties
  ;;       '(read-only t cursor-intangible t face minibuffer-prompt))
  ;; (add-hook 'minibuffer-setup-hook #'cursor-intangible-mode)

  (define-key vertico-map (kbd "C-h") #'+minibuffer-up-dir)
)
#+end_src
* orderless 
гибкий поиск по регулярным выражениям
Пакет orderless.el в Emacs предоставляет стиль завершения, который разделяет шаблон на компоненты, разделенные пробелами, и находит кандидаты, которые соответствуют всем компонентам в любом порядке
#+begin_src emacs-lisp :lexical t
(use-package orderless
  :defer 1
  ;;:custom (completion-styles '(orderless basic)))
  :config
  (setq completion-styles '(orderless flex)
        completion-category-overrides '((eglot (styles . (orderless flex))))))
#+end_src
* marginalia
#+begin_src emacs-lisp :lexical t
(use-package marginalia
  :defer 2
  :config (marginalia-mode))
#+end_src
* consult
поиск
#+begin_src emacs-lisp :lexical t
(use-package consult
  :demand t
  :config
  (consult-customize
   consult-recent-file
   consult--source-recent-file
   consult--source-buffer
   :preview-key nil)
  (define-key evil-normal-state-map (kbd "gb") 'consult-buffer)
  (define-key evil-visual-state-map (kbd "gb") 'consult-buffer)

  :general
  (+general-global-buffer
    "b" 'consult-buffer)
  :init

;; Use Consult to select xref locations with preview
;; получше чем дефолт
  ;; definitions хм 
 (setq
  xref-show-xrefs-function #'consult-xref 
  xref-show-definitions-function #'consult-xref)

  )
#+end_src
* consult-dir
#+begin_src emacs-lisp :lexical t
(use-package consult-dir
  :bind (("M-g d"   . consult-dir)
         :map minibuffer-local-completion-map
         ("M-s f" . consult-dir-jump-file)
         ("M-g d" . consult-dir))
  )
#+end_src
* consult-dir-vertico
#+begin_src emacs-lisp :lexical t
(use-feature consult-dir-vertico
  :no-require t
  :after (consult-dir vertico)
  :defines (vertico-map)
  :bind (:map vertico-map
              ("C-x C-j" . consult-dir)
              ("M-g d"   . consult-dir)
              ("M-s f"   . consult-dir-jump-file))
  )
#+end_src
* TODO consult-eglot
#+begin_src emacs-lisp :lexical t 
(use-package consult-eglot
  :defer t)
#+end_src
* consult-eglot-embark
это расширение из consult-eglot 
#+begin_src emacs-lisp :lexical t
#+end_src

* embark
#+begin_src emacs-lisp :lexical t
(use-package embark
  :after (vertico)
  :general
  (general-nmap "C-l" 'embark-act))
#+end_src

* embark-consult
#+begin_src emacs-lisp :lexical t
(use-package embark-consult
  :after (embark consult))
#+end_src

* hide-mode-line
#+begin_src emacs-lisp :lexical t
(use-package hide-mode-line
  :hook (((treemacs-mode
           eshell-mode shell-mode
           term-mode vterm-mode
           embark-collect-mode
           lsp-ui-imenu-mode
           pdf-annot-list-mode) . turn-on-hide-mode-line-mode)
         (dired-mode . (lambda()
                         (and (bound-and-true-p hide-mode-line-mode)
                              (turn-off-hide-mode-line-mode))))))
#+end_src

* corfu как замена company
#+begin_src emacs-lisp :lexical t 
(use-package corfu
  :ensure (corfu :host github :repo "minad/corfu" :files (:defaults "extensions/*"))
  :defer 5
  :custom
  (corfu-cycle t)
  (corfu-auto t)
  ;;(corfu-seperator ?-)
  (corfu-seperator ?\s)
  :config
  (global-corfu-mode)
  ;; не ясно как это работает. 
  (with-eval-after-load 'evil
    (setq evil-complete-next-func (lambda (_) (completion-at-point))))
  )
#+end_src
** проверить
#+begin_src emacs-lisp :lexical t :tangle no
(use-package corfu
  :ensure (corfu :host github :repo "minad/corfu" :files (:defaults "extensions/*"))
  :hook (lsp-completion-mode . kb/corfu-setup-lsp) ; Use corfu for lsp completion
  :general
  (:keymaps 'corfu-map
   :states 'insert
   "C-n" #'corfu-next
   "C-p" #'corfu-previous
   "<escape>" #'corfu-quit
   "<return>" #'corfu-insert
   "H-SPC" #'corfu-insert-separator
   ;; "SPC" #'corfu-insert-separator ; Use when `corfu-quit-at-boundary' is non-nil
   "M-d" #'corfu-show-documentation
   "C-g" #'corfu-quit
   "M-l" #'corfu-show-location)
  :custom
  ;; Works with `indent-for-tab-command'. Make sure tab doesn't indent when you
  ;; want to perform completion
  (completion-cycle-threshold nil)      ; Always show candidates in menu

  (corfu-auto nil)
  (corfu-auto-prefix 2)
  (corfu-auto-delay 0.25)

  (corfu-min-width 80)
  (corfu-max-width corfu-min-width)     ; Always have the same width
  (corfu-count 14)
  (corfu-scroll-margin 4)
  (corfu-cycle nil)

  ;; `nil' means to ignore `corfu-separator' behavior, that is, use the older
  ;; `corfu-quit-at-boundary' = nil behavior. Set this to separator if using
  ;; `corfu-auto' = `t' workflow (in that case, make sure you also set up
  ;; `corfu-separator' and a keybind for `corfu-insert-separator', which my
  ;; configuration already has pre-prepared). Necessary for manual corfu usage with
  ;; orderless, otherwise first component is ignored, unless `corfu-separator'
  ;; is inserted.
  (corfu-quit-at-boundary nil)
  (corfu-separator ?\s)            ; Use space
  (corfu-quit-no-match 'separator) ; Don't quit if there is `corfu-separator' inserted
  (corfu-preview-current 'insert)  ; Preview first candidate. Insert on input if only one
  (corfu-preselect-first t)        ; Preselect first candidate?

  ;; Other
  (corfu-echo-documentation nil)        ; Already use corfu-doc
  (lsp-completion-provider :none)       ; Use corfu instead for lsp completions
  :init
  (corfu-global-mode)
  :config
  ;; NOTE 2022-03-01: This allows for a more evil-esque way to have
  ;; `corfu-insert-separator' work with space in insert mode without resorting to
  ;; overriding keybindings with `general-override-mode-map'. See
  ;; https://github.com/minad/corfu/issues/12#issuecomment-869037519
  ;; Alternatively, add advice without `general.el':
  ;; (advice-add 'corfu--setup :after 'evil-normalize-keymaps)
  ;; (advice-add 'corfu--teardown :after 'evil-normalize-keymaps)
  (general-add-advice '(corfu--setup corfu--teardown) :after 'evil-normalize-keymaps)
  (evil-make-overriding-map corfu-map)

  ;; Enable Corfu more generally for every minibuffer, as long as no other
  ;; completion UI is active. If you use Mct or Vertico as your main minibuffer
  ;; completion UI. From
  ;; https://github.com/minad/corfu#completing-with-corfu-in-the-minibuffer
  (defun corfu-enable-always-in-minibuffer ()
    "Enable Corfu in the minibuffer if Vertico/Mct are not active."
    (unless (or (bound-and-true-p mct--active) ; Useful if I ever use MCT
                (bound-and-true-p vertico--input))
      (setq-local corfu-auto nil)       ; Ensure auto completion is disabled
      (corfu-mode 1)))
  (add-hook 'minibuffer-setup-hook #'corfu-enable-always-in-minibuffer 1)

  ;; Setup lsp to use corfu for lsp completion
  (defun kb/corfu-setup-lsp ()
    "Use orderless completion style with lsp-capf instead of the
default lsp-passthrough."
    (setf (alist-get 'styles (alist-get 'lsp-capf completion-category-defaults))
          '(orderless))))
#+end_src

* corfu-doc замена company-quickhelp(OBSULUTE) . Использовать corfu-popinfo
#+begin_src emacs-lisp :lexical t :tangle no
(use-package corfu-doc
  ;; NOTE 2022-02-05: At the time of writing, `corfu-doc' is not yet on melpa
  :ensure (corfu-doc :host github :repo "galeo/corfu-doc")
  :after corfu
  :hook (corfu-mode . corfu-doc-mode)
  :general (:keymaps 'corfu-map
            ;; This is a manual toggle for the documentation popup.
            [remap corfu-show-documentation] #'corfu-doc-toggle ; Remap the default doc command
            ;; Scroll in the documentation window
            "M-n" #'corfu-doc-scroll-up
            "M-p" #'corfu-doc-scroll-down)
  :custom
  (corfu-doc-delay 0.5)
  (corfu-doc-max-width 70)
  (corfu-doc-max-height 20)

  ;; NOTE 2022-02-05: I've also set this in the `corfu' use-package to be
  ;; extra-safe that this is set when corfu-doc is loaded. I do not want
  ;; documentation shown in both the echo area and in the `corfu-doc' popup.
  (corfu-echo-documentation nil))
#+end_src

* corfu-popinfo
#+begin_src emacs-lisp :lexical t
(use-feature corfu-popupinfo
  :after corfu
  :hook (corfu-mode . corfu-popupinfo-mode)
  :config
  (setq corfu-popinfo-delay '(0.5 . 1.0)))
#+end_src

* cape
[[https://kristofferbalintona.me/posts/202203130102/][Cape | Kristoffer Balintona]]
#+begin_src emacs-lisp :lexical t 
(use-package cape
  :general (:prefix "M-c"               ; Particular completion function
            "p" 'completion-at-point
            "t" 'complete-tag           ; etags
            "d" 'cape-dabbrev           ; or dabbrev-completion
            "f" 'cape-file
            "k" 'cape-keyword
            "s" 'cape-symbol
            "a" 'cape-abbrev
            "i" 'cape-ispell
            "l" 'cape-line
            "w" 'cape-dict
            "\\"' cape-tex
            "_" 'cape-tex
            "^" 'cape-tex
            "&" 'cape-sgml
            "r" 'cape-rfc1345
            )
  :custom
  (cape-dabbrev-min-length 3)
  :init
  ;; Add to the global default value of `completion-at-point-functions' which is
  ;; used by `completion-at-point'.  The order of the functions matters, the
  ;; first function returning a result wins.  Note that the list of buffer-local
  ;; completion functions takes precedence over the global list.
  (add-to-list 'completion-at-point-functions #'cape-dabbrev)
  (add-to-list 'completion-at-point-functions #'cape-file)
  (add-to-list 'completion-at-point-functions #'cape-elisp-block)
  ;;(add-to-list 'completion-at-point-functions #'cape-history)
  ;;(add-to-list 'completion-at-point-functions #'cape-keyword)
  ;;(add-to-list 'completion-at-point-functions #'cape-tex)
  ;;(add-to-list 'completion-at-point-functions #'cape-sgml)
  ;;(add-to-list 'completion-at-point-functions #'cape-rfc1345)
  ;;(add-to-list 'completion-at-point-functions #'cape-abbrev)
  ;;(add-to-list 'completion-at-point-functions #'cape-dict)
  ;;(add-to-list 'completion-at-point-functions #'cape-elisp-symbol)
  ;;(add-to-list 'completion-at-point-functions #'cape-line)
)
#+end_src

* kind icon замена company-box-icons
#+begin_src emacs-lisp :lexical t :tangle no 
(use-package kind-icon
  :after corfu
  :custom
  (kind-icon-use-icons t)
  (kind-icon-default-face 'corfu-default) ; Have background color be the same as `corfu' face background
  ;;(kind-icon-blend-background nil)  ; Use midpoint color between foreground and background colors ("blended")?
  ;;(kind-icon-blend-frac 0.08)

  ;; NOTE 2022-02-05: `kind-icon' depends `svg-lib' which creates a cache
  ;; directory that defaults to the `user-emacs-directory'. Here, I change that
  ;; directory to a location appropriate to `no-littering' conventions, a
  ;; package which moves directories of other packages to sane locations.
  ;;(svg-lib-icons-dir (no-littering-expand-var-file-name "svg-lib/cache/")) ; Change cache dir
  :config
  (add-to-list 'corfu-margin-formatters #'kind-icon-margin-formatter)) ; Enable `kind-icon'

  ;; Add hook to reset cache so the icon colors match my theme
  ;; NOTE 2022-02-05: This is a hook which resets the cache whenever I switch
  ;; the theme using my custom defined command for switching themes. If I don't
  ;; do this, then the backgound color will remain the same, meaning it will not
  ;; match the background color corresponding to the current theme. Important
  ;; since I have a light theme and dark theme I switch between. This has no
  ;; function unless you use something similar
 ;; (add-hook 'kb/themes-hooks #'(lambda () (interactive) (kind-icon-reset-cache))))
#+end_src

* nerd-icons-corfu

#+begin_src emacs-lisp :lexical t
(use-package nerd-icons-corfu
  :after corfu
  :init (add-to-list 'corfu-margin-formatters #'nerd-icons-corfu-formatter))
#+end_src

* TODO hydra
(use-package hydra) 
* quickrun
#+begin_src emacs-lisp :lexical t
(use-package quickrun
  :bind (("C-<f5>" . quickrun)
         ("C-c X"  . quickrun)))
#+end_src

* TODO Emacs-lsp
** lsp-mode
#+begin_src emacs-lisp :lexical t :tangle no
(use-package lsp-mode
  :hook ((c-mode . lsp)
         (c++-mode . lsp)
         (c-or-c++-mode . lsp)
         (js-mode . lsp)
         (js-jsx-mode . lsp)
         (typescript-mode . lsp)
         (python-ts-mode . lsp)
         (web-mode . lsp)
         (haskell-mode . lsp)
         (lsp-mode . lsp-enable-which-key-integration))
  ;; . lsp-deferred
  ;;:commands lsp
  :custom
  (lsp-completion-provider :none) 
  (lsp-completion-show-kind nil)
  (lsp-completion-show-detail nil)
  ;; :init
  ;;   (setq lsp-enabled-clients '(jedi 
  ;;                             sqls
  ;;                             jdtls
  ;;                             ))
  :config
  (setq lsp-auto-guess-root t)
  ;; (add-to-list 'lsp-enabled-clients 'jdtls)
  (setq lsp-enabled-clients '(jdtls jedi))
  (setq lsp-disabled-clients '(pyls pylsp))
  ;; (setq lsp-log-io nil)
  (setq lsp-restart 'auto-restart)
  ;; (setq lsp-enable-symbol-highlighting nil) ;; у него тут t
  ;; lsp-warn-no-matched-clients t) ;; и это у него включено 
  ;; (setq lsp-enable-on-type-formatting nil)
  ;; (setq lsp-signature-auto-activate nil)
  ;; (setq lsp-signature-render-documentation nil)
  ;; (setq lsp-eldoc-hook nil)
  ;; (setq lsp-modeline-code-actions-enable nil)
  ;; (setq lsp-modeline-diagnostics-enable nil)
  ;; (setq lsp-headerline-breadcrumb-enable nil)
  ;; (setq lsp-semantic-tokens-enable nil)
  ;; (setq lsp-enable-folding nil)
  ;; (setq lsp-enable-imenu nil)
  ;; (setq lsp-enable-snippet nil)
  (setq read-process-output-max (* 1024 1024)) ;; 1MB
  (setq lsp-idle-delay 0.5)

  ;;emacs-lsp-booster
  (defun lsp-booster--advice-json-parse (old-fn &rest args)
  "Try to parse bytecode instead of json."
  (or
   (when (equal (following-char) ?#)
     (let ((bytecode (read (current-buffer))))
       (when (byte-code-function-p bytecode)
         (funcall bytecode))))
   (apply old-fn args)))
(advice-add (if (progn (require 'json)
                       (fboundp 'json-parse-buffer))
                'json-parse-buffer
              'json-read)
            :around
            #'lsp-booster--advice-json-parse)

(defun lsp-booster--advice-final-command (old-fn cmd &optional test?)
  "Prepend emacs-lsp-booster command to lsp CMD."
  (let ((orig-result (funcall old-fn cmd test?)))
    (if (and (not test?)                             ;; for check lsp-server-present?
             (not (file-remote-p default-directory)) ;; see lsp-resolve-final-command, it would add extra shell wrapper
             lsp-use-plists
             (not (functionp 'json-rpc-connection))  ;; native json-rpc
             (executable-find "emacs-lsp-booster"))
        (progn
          (when-let ((command-from-exec-path (executable-find (car orig-result))))  ;; resolve command from exec-path (in case not found in $PATH)
            (setcar orig-result command-from-exec-path))
          (message "Using emacs-lsp-booster for %s!" orig-result)
          (cons "emacs-lsp-booster" orig-result))
      orig-result)))
(advice-add 'lsp-resolve-final-command :around #'lsp-booster--advice-final-command)


  )
#+end_src
** lsp-ui
#+begin_src emacs-lisp :lexical t :tangle no
(use-package lsp-ui
  :after lsp
  :commands lsp-ui-mode
  :config
  (setq lsp-ui-doc-enable nil)
  (setq lsp-ui-doc-header t)
  (setq lsp-ui-doc-include-signature t)
  (setq lsp-ui-doc-border (face-foreground 'default))
  (setq lsp-ui-sideline-show-code-actions t)
  (setq lsp-ui-sideline-delay 0.05))
#+end_src
** lsp-jedi
#+begin_src emacs-lisp :lexical t :tangle no
(use-package lsp-jedi
  :after lsp-mode
  ;; :config
  ;; (add-to-list 'lsp-disabled-clients 'pyls)
  ;; (add-to-list 'lsp-disabled-clients 'pylsp)
  ;; (add-to-list 'lsp-enabled-clients 'jedi))
  )
#+end_src
** lsp-java
#+begin_src emacs-lisp :lexical t :tangle no
(use-package lsp-java
  :after lsp
  :hook (java-ts-mode . lsp-deferred))
#+end_src

** lsp-treemacs
#+begin_src emacs-lisp :lexical t :tangle no
(use-package lsp-treemacs
  :after (lsp-mode)
  :init
  (lsp-treemacs-sync-mode 1))
#+end_src

** python lsp-pyright
#+begin_src emacs-lisp :lexical t :tangle no
(use-package lsp-pyright
  :hook (python-mode . (lambda () (require 'lsp-pyright)))
  :init (when (executable-find "python3")
          (setq lsp-pyright-python-executable-cmd "python3")))
#+end_src
* eglot
** general 
#+begin_src emacs-lisp :lexical t 
(use-feature eglot
  :hook
  (
   ;;(python-mode . eglot-ensure)
   ;;(c-mode . eglot-ensure)
   ;;(c++-mode . eglot-ensure)
   ;(java-ts-mode . eglot-ensure)
   (scala . eglot-ensure
   ))
  :custom
  (eglot-autoshutdown t)
  (eglot-report-progress nil)
  (eglot-stay-out-of '())
  (eglot-extend-to-xref t)
  (eglot-send-changes-idle-time 0.5)
                     
  :config
  (setq eglot-ignored-server-capabilities '(:documentHighlightProvider
                                            :foldingRangeProvider))
  (cl-callf plist-put eglot-events-buffer-config :size 0)
  (push '((java-mode java-ts-mode) . jdtls-command-contact) eglot-server-programs)
  :init
  (defun +eglot-register (modes &rest servers)
    "Register MODES with LSP SERVERS.
     Examples:
     (+eglot-register 'vhdl-mode \"vhdl_ls\")
     (+eglot-register 'lua-mode \"lua-language-server\" \"lua-lsp\")
     (+eglot-register '(c-mode c++-mode) '(\"clangd\" \"--clang-tidy\" \"-j=12\") \"ccls\")"
    (declare (indent 0))
    (with-eval-after-load 'eglot
      (add-to-list
       'eglot-server-programs
       (cons modes (if (length> servers 1)
                       (eglot-alternatives (ensure-list servers))
                     (ensure-list (car servers)))))))

)
#+end_src

** eglot-java
#+begin_src emacs-lisp :lexical t 
(use-package eglot-java
  :ensure (eglot-java :host github :repo "yveszoundi/eglot-java" :files (:defaults "*.el"))
  :custom
  (eglot-java-eclipse-jdt-args
   '("-XX:+UseAdaptiveSizePolicy"
     "-XX:GCTimeRatio=4"
     "-XX:AdaptiveSizePolicyWeight=90"
     "-Xmx8G"
     "-Xms2G"
     ))
  :config
  (defun eglot-java-run-main-fork ()
    "Run a main class."
    (interactive)
    (let* ((fqcn (eglot-java--class-fqcn))
           (cp   (eglot-java--project-classpath (buffer-file-name) "runtime")))
      (if fqcn
          (compile
           (concat "java -cp "
                   (mapconcat #'identity cp path-separator)
                   " "
                   fqcn)
           t)
        (user-error "No main method found in this file! Is the file saved?!"))))
  ;; :hook (java-ts-mode . eglot-java-mode)
  )
#+end_src

** eglot-java extra
#+begin_src emacs-lisp :lexical t :tangle no
  (with-eval-after-load 'eglot

  (defvar +eglot/display-buf "*+eglot/display-buffer*")
  (defvar +eglot/display-frame nil)
  (defvar +eglot/hover-last-point nil)
  (defface +eglot/display-border '((((background dark)) . (:background "white"))
                                   (((background light)) . (:background "black")))
    "The border color used in childframe.")

  (cl-defgeneric +eglot/workspace-configuration (server)
    "Set workspace configuration,
- Handle server request `workspace/configuration'
- Send a `workspace/didChangeConfiguration' signal to SERVER"
    nil)
  (setq-default eglot-workspace-configuration #'+eglot/workspace-configuration)

  ;; Hover
  (defun +eglot/show-hover-at-point ()
    (interactive)
    (when (eglot-server-capable :hoverProvider)
      (let ((buf (current-buffer)))
        (jsonrpc-async-request
         (eglot--current-server-or-lose)
         :textDocument/hover (eglot--TextDocumentPositionParams)
         :success-fn (eglot--lambda ((Hover) contents range)
                       (eglot--when-buffer-window buf
                         (if-let ((info (unless (seq-empty-p contents)
                                          (eglot--hover-info contents range))))
                             (progn
                               (with-current-buffer (get-buffer-create +eglot/display-buf)
                                 (erase-buffer)
                                 (insert info))
                               (setq +eglot/display-frame
                                     (posframe-show
                                      (get-buffer-create +eglot/display-buf)
                                      :border-width 1
                                      :border-color (face-background '+eglot/display-border nil t)
                                      :max-height (/ (frame-height) 3)
                                      :max-width (/ (frame-width) 3)
                                      :poshandler 'posframe-poshandler-point-bottom-left-corner-upward))
                               (run-with-timer 0.1 nil #'+eglot/hide-hover))
                           (message "LSP No Hover Document"))))
         :deferred :textDocument/hover))
      (setq +eglot/hover-last-point (point))))

  (defun +eglot/hide-hover ()
    (if (or (eq (point) +eglot/hover-last-point)
            (eq (selected-frame) +eglot/display-frame))
        (run-with-timer 0.1 nil #'+eglot/hide-hover)
      (posframe-hide +eglot/display-buf))))

#+end_src
** eglot-java-extra
#+begin_src emacs-lisp :lexical t :tangle no
(with-eval-after-load 'eglot
  ;; ----------------------- Intialization/Configurations -----------------------
  ;; (jsonrpc--json-encode (jdtls-initialization-options))
  (defun jdtls-initialization-options ()
    `(:settings (:java (:autobuild (:enabled t)
                        :format (:settings (:url ,(expand-file-name (user-emacs-directory "share/eclipse-format.xml"))
                                            :profile "CodeFormatterProfile"))
                        :completion (:guessMethodArguments t
                                     :lazyResolveTextEdit (:enabled t)
                                     :favoriteStaticMembers ["org.junit.Assert.*"
                                                             "org.junit.Assume.*"
                                                             "org.junit.jupiter.api.Assertions.*"
                                                             "org.junit.jupiter.api.Assumptions.*"
                                                             "org.junit.jupiter.api.DynamicContainer.*"
                                                             "org.junit.jupiter.api.DynamicTest.*"
                                                             "org.mockito.Mockito.*"
                                                             "org.mockito.ArgumentMatchers.*"
                                                             "org.mockito.Answers.*"])
                        :edit (:validateAllOpenBuffersOnChanges :json-false)
                        ;; Javadoc generation, https://github.com/mfussenegger/nvim-jdtls/issues/76#issuecomment-831448277
                        :codeGeneration (:generateComments t)))
      :extendedClientCapabilities (:classFileContentsSupport t
                                   :overrideMethodsPromptSupport t)
      :bundles ,(if-let* ((bundles-dir (file-name-concat user-emacs-directory "cache" "lsp-servers" "java" "bundles"))
                          (_ (file-directory-p bundles-dir))
                          (jars (directory-files bundles-dir t "\\.jar$")))
                    (apply #'vector jars)
                  [])))
    (cl-defmethod eglot-initialization-options (server &context (major-mode java-mode))
    (jdtls-initialization-options))

  (cl-defmethod eglot-initialization-options (server &context (major-mode java-ts-mode))
    (jdtls-initialization-options))

  (cl-defmethod +eglot/workspace-configuration (server &context (major-mode java-mode))
    (plist-get (jdtls-initialization-options) :settings))

  (cl-defmethod +eglot/workspace-configuration (server &context (major-mode java-ts-mode))
    (plist-get (jdtls-initialization-options) :settings))

  ;; ----------------------- Support URI jdt:// protocol -----------------------
  (defun +java/eglot-find-jdt-server ()
    (let ((filter-fn (lambda (server)
                       (cl-loop for (mode . languageid) in
                                (eglot--languages server)
                                when (string= languageid "java")
                                return languageid)))
          (servers (gethash (eglot--current-project) eglot--servers-by-project)))
      (cl-find-if filter-fn servers)))

  (defun +java/eglot-jdt-uri-handler (operation &rest args)
    "Support Eclipse jdtls `jdt://' uri scheme."
    (let* ((uri (car args))
           (cache-dir (expand-file-name "eglot-java" (temporary-file-directory)))
           (_ (string-match "jdt://contents/\\(.*?\\)/\\(.*\\)\.class\\?" uri))
           (jar-file (substring uri (match-beginning 1) (match-end 1)))
           (java-file (format "%s.java" (replace-regexp-in-string "/" "." (substring uri (match-beginning 2) (match-end 2)) t t)))
           (jar-dir (concat (file-name-as-directory cache-dir)
                            (file-name-as-directory jar-file)))
           (source-file (expand-file-name (concat jar-dir java-file))))
      (unless (file-readable-p source-file)
        (let ((content (jsonrpc-request
                        (or (eglot-current-server)
                            ;; NOTE: dape https://github.com/svaante/dape/issues/78#issuecomment-1966786597
                            (+java/eglot-find-jdt-server))
                        :java/classFileContents (list :uri uri))))
          (unless (file-directory-p jar-dir) (make-directory jar-dir t))
          (with-temp-file source-file (insert content))))
      (cond
       ((eq operation 'expand-file-name) source-file)
       ((eq operation 'file-truename) source-file)
       ((eq operation 'file-local-name) source-file)
       ((eq operation 'file-remote-p) nil)
       ;; Handle any operation we don’t know about.
       (t (let ((inhibit-file-name-handlers
                 (cons '+java/eglot-jdt-uri-handler
                       (and (eq inhibit-file-name-operation operation)
                            inhibit-file-name-handlers)))
                (inhibit-file-name-operation operation))
            (apply operation args))))))
  (add-to-list 'file-name-handler-alist '("\\`jdt://" . +java/eglot-jdt-uri-handler))

  ;; ----------------------- Support jdt.ls extra commands -----------------------
  ;; (defun java-apply-workspaceEdit (arguments)
  ;;   "Command `java.apply.workspaceEdit' handler."
  ;;   (mapc #'eglot--apply-workspace-edit arguments this-command))

  (defun java-action-overrideMethodsPrompt (arguments)
    "Command `java.action.overrideMethodsPrompt' handler."
    (let* ((argument (aref arguments 0))
           (list-methods-result (jsonrpc-request (eglot--current-server-or-lose)
                                                 :java/listOverridableMethods
                                                 argument))
           (methods (plist-get list-methods-result :methods))
           (menu-items (mapcar (lambda (method)
                                 (let* ((name (plist-get method :name))
                                        (parameters (plist-get method :parameters))
                                        (class (plist-get method :declaringClass)))
                                   (cons (format "%s(%s) class: %s" name (string-join parameters ", ") class) method)))
                               methods))
           ;; use ";" instead of "," to separate strings in completing-read-multiple
           (crm-separator "[ \t]*;[ \t]*")
           (selected-methods (cl-map 'vector
                                     (lambda (choice) (alist-get choice menu-items nil nil 'equal))
                                     (delete-dups
                                      (completing-read-multiple "overridable methods: " menu-items))))
           (add-methods-result (jsonrpc-request (eglot--current-server-or-lose)
                                                :java/addOverridableMethods
                                                (list :overridableMethods selected-methods :context argument))))
      (eglot--apply-workspace-edit add-methods-result this-command)))

  (defun +java/execute-command (server _command)
    (eglot--dbind ((Command) command arguments) _command
      (pcase command
        ;; ("java.apply.workspaceEdit" (java-apply-workspaceEdit arguments))
        ("java.action.overrideMethodsPrompt" (java-action-overrideMethodsPrompt arguments))
        (_ (eglot--request server :workspace/executeCommand _command)))))
(defun +java/eglot-execute (server action)
    "Ask SERVER to execute ACTION.
ACTION is an LSP object of either `CodeAction' or `Command' type."
    (eglot--dcase action
      (((Command)) (+java/execute-command server action))
      (((CodeAction) edit command data)
       (if (and (null edit) (null command) data
                (eglot-server-capable :codeActionProvider :resolveProvider))
           (eglot-execute server (eglot--request server :codeAction/resolve action))
         (when edit (eglot--apply-workspace-edit edit this-command))
         (when command (+java/execute-command server command))))))

  (cl-defmethod eglot-execute (server action &context (major-mode java-mode))
    (+java/eglot-execute server action))

  (cl-defmethod eglot-execute (server action &context (major-mode java-ts-mode))
    (+java/eglot-execute server action)))

  

  
#+end_src

** extra 2
#+begin_src emacs-lisp :lexical t :tangle no
;; Run junit console
(with-eval-after-load 'java-ts-mode
  ;; Download `junit-platform-console-standalone.jar'
  (defvar +java/junit-platform-console-standalone-jar
    (expand-file-name (locate-user-emacs-file "cache/lsp-servers/java/junit-console/junit-platform-console-standalone.jar")))

  ;; (+funcs/major-mode-leader-keys
  ;;  java-ts-mode-map
  ;;  "r" '(+java/junit-console-run-dwim :which-key "junit-console-run-dwim"))

  ;; check junit console launcher options for details
  (defun +java/junit-console-run-dwim ()
    "Java run main/test at point."
    (interactive)
    (let* ((pkg (+java/treesit-get-package))
           (class (+java/treesit-get-class))
           (method (+java/treesit-get-method))
           (classpath (+java/eglot-get-project-classpath)))
      (if (and pkg class classpath)
          (compile
           (concat "java -jar " +java/junit-platform-console-standalone-jar
                   " -cp " classpath
                   (if method
                       (format " -m '%s.%s#%s'" pkg class method)
                     (format " -c '%s.%s'" pkg class)))
           t)
        (message "Can not found package/class/classpath"))))

  (defun +java/treesit-get-package-node ()
    (treesit-node-text
     (car
      (treesit-filter-child
       (treesit-buffer-root-node)
       (lambda (child)
         (member (treesit-node-type child) '("package_declaration")))))
     t))

  (defun +java/treesit-get-package ()
    (let ((p (+java/treesit-get-package-node)))
      (when (string-match "package \\(.+\\);" p)
        (match-string 1 p))))

  (defun +java/treesit-get-class ()
    (treesit-defun-name
     (car
      (treesit-filter-child
       (treesit-buffer-root-node)
       (lambda (child)
         (member (treesit-node-type child) '("class_declaration")))))))

  (defun +java/treesit-get-method ()
    (treesit-defun-name
     (treesit-parent-until
      (treesit-node-at (point))
      (lambda (parent)
        (member (treesit-node-type parent) '("method_declaration"))))))

  (defun +java/maven-get-deps-classpath (target-location)
    "Get dependencies classpath."
    (let* ((project-root-path (+project/root))
           (default-directory project-root-path)
           (deps-cp-file (format "%s/deps-cp" target-location)))
      (unless (file-exists-p deps-cp-file)
        ;; NOTE: Cache deps classpath to speed up shell command, regenerate it once you modify project dependencies.
        (shell-command-to-string "mvn test-compile dependency:build-classpath -Dmdep.includeScope=test -Dmdep.outputFile=target/deps-cp"))
      (with-temp-buffer
        (insert-file-contents deps-cp-file)
        (buffer-string))))

  (defun +java/maven-get-project-classpath ()
    (when-let* ((target-location (expand-file-name (locate-dominating-file default-directory "target")))
                (target-path (format "%starget" target-location))
                (deps-cp (+java/maven-get-deps-classpath target-path)))
      (format "%s/classes:%s/test-classes:%s" target-path target-path deps-cp)))

  (defun +java/eglot-get-project-classpath (&optional filename scope)
    (let* ((filename (or filename (buffer-file-name)))
           (scope (or scope "test"))
           (command (list
                     :title ""
                     :command "java.project.getClasspaths"
                     :arguments (vector (eglot-path-to-uri filename)
                                        (json-serialize (list :scope scope)))))
           (classpaths (plist-get (eglot-execute (eglot--current-server-or-lose) command) :classpaths)))
      (mapconcat #'identity classpaths path-separator)))

  (defun +java/testfile-p (file-path)
    "Tell if a file locate at FILE-PATH is a test class."
    (let ((command (list
                    :title ""
                    :command "java.project.isTestFile"
                    :arguments (vector (eglot-path-to-uri file-path)))))
      (eq t (eglot-execute (eglot--current-server-or-lose) command)))))

;; ==================== Viewing Java Class Files in Emacs ====================
;;
;; https://nullprogram.com/blog/2012/08/01/
;;
(defun javap-handler (operation &rest args)
  "Handle .class files by putting the output of javap in the buffer."
  (cond
   ((eq operation 'get-file-buffer)
    (let ((file (car args)))
      (with-current-buffer (create-file-buffer file)
        (call-process "javap" nil (current-buffer) nil "-verbose"
                      "-classpath" (file-name-directory file)
                      (file-name-sans-extension
                       (file-name-nondirectory file)))
        (setq buffer-file-name file)
        (setq buffer-read-only t)
        (set-buffer-modified-p nil)
        (goto-char (point-min))
        ;; (java-mode)
        (current-buffer))))
   ;; Run the real handler without the javap handler installed
   (t (let ((inhibit-file-name-handlers
             (cons 'javap-handler
                   (and (eq inhibit-file-name-operation operation)
                        inhibit-file-name-handlers)))
            (inhibit-file-name-operation operation))
        (apply operation args)))))

(add-to-list 'file-name-handler-alist '("\\.class$" . javap-handler))
#+end_src

** eglot-booster
#+begin_src emacs-lisp :lexical t :tangle yes
(use-package eglot-booster
  :ensure (eglot-booster :host github :repo "jdtsmith/eglot-booster")
	:after eglot
	:config	(eglot-booster-mode))
#+end_src
** пример Eglot, corfu, cape, temple, eglot-tempel
#+begin_src emacs-lisp :lexical t :tangle no
(leaf eglot
  :straight t
  :hook
  ((rust-mode-hook . eglot-ensure))
  :custom
  ((eglot-ignored-server-capabilities . '(:documentHighlightProvider :inlayHintProvider))))

(leaf corfu
  :straight
  (corfu :host github :repo "minad/corfu" :files (:defaults "extensions/*"))
  :custom
  ((corfu-auto . t)
   (corfu-auto-prefix . 1)
   (corfu-quit-no-match . nil)
   (corfu-popupinfo-delay . 0.3)
   (corfu-popupinfo-max-width . 70)
   (corfu-popupinfo-max-height . 20))
  :init
  (require 'corfu)
  (global-corfu-mode 1)
  (corfu-popupinfo-mode 1)
  (setq corfu-map (make-keymap)))

(leaf cape
  :straight t
  :init
  (add-to-list 'completion-at-point-functions #'cape-dabbrev)
  (add-to-list 'completion-at-point-functions #'cape-file)
  (add-to-list 'completion-at-point-functions #'cape-elisp-block)
  (advice-add 'eglot-completion-at-point :around #'cape-wrap-buster))

(leaf tempel
  :straight t
  :init
  (add-hook 'eglot-managed-mode-hook
            (lambda ()
              (setq-local completion-at-point-functions
                          (list (cape-super-capf
                                 #'eglot-completion-at-point
                                 #'tempel-expand
                                 #'cape-keyword))))))

(leaf eglot-tempel
  :after eglot
  :straight (eglot-tempel :host github :repo "fejfighter/eglot-tempel"))
#+end_src
* eglot-hierarchy
#+begin_src emacs-lisp :lexical t 
(use-package eglot-hierarchy
  :ensure (eglot-hierarchy :host github :repo "dolmens/eglot-hierarchy")
  :defer t)
#+end_src

* Java-ts-mode
#+begin_src emacs-lisp :lexical t :tangle yes
;; (use-feature java-ts-mode
;;   :mode "\\.java\\'")
#+end_src
* groovy-mode
#+begin_src emacs-lisp :lexical t :tangle yes
(use-package groovy-mode 
:mode (("build\\.gradle" . groovy-mode)
       ("Jenkinsfile" . groovy-mode))
:config
(+eglot-register '(groovy-mode) "groovy-language-server"))
#+end_src
* kotlin-ts-mode
#+begin_src emacs-lisp :lexical t :tangle yes
(use-package kotlin-ts-mode 
  :ensure (kotlin-ts-mode :host gitlab :repo "bricka/emacs-kotlin-ts-mode")
  :mode "\\.kts?m?\\'")
#+end_src
* elixir-ts-mode
#+begin_src emacs-lisp :lexical t
(use-package elixir-ts-mode
    :mode (("\\.ex\\'" . elixir-ts-mode)
           ("\\.exs\\'" . elixir-ts-mode)
           ("\\mix.lock\\'" . elixir-ts-mode)))
#+end_src
* erlang mode 
* go
* rust
* ruby
* clojure
* haskell
* scala
#+begin_src emacs-lisp :lexical t
(use-package scala-mode
  :defer t
  :interpreter ("scala" . scala-mode))
#+end_src

#+begin_src emacs-lisp :lexical t
(use-package sbt-mode
  :defer t
  :commands sbt-start sbt-command
  :config
  ;; WORKAROUND: https://github.com/ensime/emacs-sbt-mode/issues/31
  ;; allows using SPACE when in the minibuffer
  (substitute-key-definition
   'minibuffer-complete-word
   'self-insert-command
   minibuffer-local-completion-map)
   ;; sbt-supershell kills sbt-mode:  https://github.com/hvesalai/emacs-sbt-mode/issues/152
   (setq sbt:program-options '("-Dsbt.supershell=false")))
#+end_src

* racket scheme guile geiser
HTDP + SICP
#+begin_src emacs-lisp :lexical t
(use-package racket-mode
  :defer t
  :hook (racket-mode . racket-xp-mode)
 ;;   (define-key racket-mode-map (kbd "<up>") (kbd "M-p"))
 ;; (define-key racket-mode-map (kbd "<down>") (kbd "M-n"))
  )
#+end_src

#+begin_src emacs-lisp :lexical t
(use-package geiser
  :defer t
  
  :custom
  (geiser-default-implementation 'guile))
#+end_src

#+begin_src emacs-lisp :lexical t
(use-package geiser-chez
  :defer t
  )
#+end_src

#+begin_src emacs-lisp :lexical t
(use-package geiser-guile
  :defer t
  )
#+end_src

#+begin_src emacs-lisp :lexical t
(use-package geiser-mit
  :defer t
  )
#+end_src

#+begin_src emacs-lisp :lexical t
;(use-package geiser-racket
;  :defer t
;  )
#+end_src

#+begin_src emacs-lisp :lexical t
(use-package macrostep-geiser
  :after (geiser)
  :hook ((geiser-mode geiser-repl-mode) . macrostep-geiser-setup)
  ;; :init
  ;; (+map-local! :keymaps '(geiser-mode-map geiser-repl-mode-map)
  ;;   "m" '(macrostep-expand :wk "Expand macro")
  ;;   "M" #'macrostep-geiser-expand-all)
  )
#+end_src

* sql
#+begin_src emacs-lisp :lexical t
(add-hook 'sql-mode-hook 'lsp)
(setq lsp-sqls-workspace-config-path nil)
(setq lsp-sqls-connections
    '(
       ((driver . "postgresql") (dataSourceName . "host=127.0.0.1 port=5432 user=postgres password=root dbname=testdb sslmode=disable"))
      ))
#+end_src
* TODO ansible
* TODO web-mode JS TS HTML 
[[https://github.com/seagle0128/.emacs.d/blob/9722d41abee93f8f6a28b36c3f7cb8795ada6a5a/lisp/init-web.el#L118][.emacs.d/lisp/init-web.el at 9722d41abee93f8f6a28b36c3f7cb8795ada6a5a · seagl...]]
#+begin_src emacs-lisp :lexical t
(use-package web-mode
  :defer t
  :mode
  "\\.\\(phtml\\|php\\|[gj]sp\\|as[cp]x\\|erb\\|djhtml\\|html?\\|hbs\\|ejs\\|jade\\|swig\\|tm?pl\\|vue\\)$"
  :config
  (setq web-mode-markup-indent-offset 2)
  (setq web-mode-css-indent-offset 2)
  (setq web-mode-code-indent-offset 2))
#+end_src

* dap-mode
#+begin_src emacs-lisp :lexical t
(use-package dap-mode
  :after lsp-mode
  :config
  (dap-mode t))
#+end_src
* move-text
Двигаем текст между строк. 
#+begin_src emacs-lisp :lexical t
(use-package move-text
  :bind (("M-p" . move-text-up)
         ("M-n" . move-text-down))
  :config (move-text-default-bindings))
#+end_src
* eldoc
#+begin_src emacs-lisp :lexical t :tangle no
(use-package eldoc
  :preface
  (unload-feature 'eldoc t)
  (setq custom-delayed-init-variables '())
  (defvar global-eldoc-mode nil)
  :config
  (global-eldoc-mode))
#+end_src

* treesit-auto
#+begin_src emacs-lisp :lexical t :tangle yes 
(use-package treesit-auto
  :custom
  (treesit-auto-install 'prompt)
  :config
  (treesit-auto-add-to-auto-mode-alist 'all)
  (global-treesit-auto-mode))
#+end_src

* jsonrpc
#+begin_src emacs-lisp :lexical t
;;(use-package jsonrpc)
#+end_src

* nxml-mode
#+begin_src emacs-lisp :lexical t 
(use-feature nxml-mode
  :mode "\\.xml\\'"
  :config
  (+eglot-register '(nxml-mode xml-mode) "lemminx"))
#+end_src

* TODO sly Common lisp
#+begin_src emacs-lisp :lexical t
(use-package sly
  :hook ((lisp-mode-local-vars . sly-editing-mode))
  :custom
  (sly-net-coding-system 'utf-8-unix)
  (sly-complete-symbol-function 'sly-simple-completions) ;; быстрее ?
  (sly-kill-without-query-p t)
  :config
  (setq sly-mrepl-history-file-name (concat user-emacs-directory "sly-mrepl-history"))

  
  (dolist (impl '("lisp"   ; Default Lisp implementation on the system
                  "clisp"  ; GNU CLISP
                  "abcl"   ; Armed Bear Common Lisp
                  "ecl"    ; Embeddable Common-Lisp
                  "gcl"    ; GNU Common Lisp
                  "ccl"    ; Clozure Common Lisp
                  "cmucl"  ; CMU Common Lisp
                  "clasp"  ; Common Lisp on LLVM
                  "sbcl")) ; Steel Bank Common Lisp
    (when (executable-find impl)
      (add-to-list
       'sly-lisp-implementations
       `(,(intern impl) (,impl) :coding-system utf-8-unix))))
  (setq inferior-lisp-program (caar (cdar sly-lisp-implementations))
        sly-default-lisp (caar sly-lisp-implementations))
  ;;;
    (defun +common-lisp--cleanup-sly-maybe-h ()
    "Kill processes and leftover buffers when killing the last sly buffer."
    (unless (cl-loop for buf in (delq (current-buffer) (buffer-list))
                     if (and (buffer-local-value 'sly-mode buf)
                             (get-buffer-window buf))
                     return t)
      (dolist (conn (sly--purge-connections))
        (sly-quit-lisp-internal conn 'sly-quit-sentinel t))
      (let (kill-buffer-hook kill-buffer-query-functions)
        (mapc #'kill-buffer
              (cl-loop for buf in (delq (current-buffer) (buffer-list))
                       if (buffer-local-value 'sly-mode buf)
                       collect buf)))))
 ;;;
    (defun doom-temp-buffer-p (buf)
      "Returns non-nil if BUF is temporary."
      (equal (substring (buffer-name buf) 0 1) " "))

 ;;;   
    (progn
      (defun +common-lisp-init-sly-h nil
        "Attempt to auto-start sly when opening a lisp buffer."
        (cond ((or (doom-temp-buffer-p (current-buffer)) (sly-connected-p)))
              ((executable-find (car (split-string inferior-lisp-program)))
               (let ((sly-auto-start 'always))
                 (sly-auto-start)
                 (add-hook 'kill-buffer-hook
                           (function +common-lisp--cleanup-sly-maybe-h) nil t)))
              ((message "WARNING: Couldn't find `inferior-lisp-program' (%s)"
                        inferior-lisp-program))))
      (dolist (hook '(sly-mode-hook))
        (dolist (func (list (function +common-lisp-init-sly-h)))
          (add-hook hook func nil nil))))

  
  :init
  
  (progn
    (progn
      (with-eval-after-load 'emacs
        (remove-hook 'lisp-mode-hook (function sly-editing-mode))))
    (progn
      (with-eval-after-load 'sly
        (remove-hook 'lisp-mode-hook (function sly-editing-mode)))))


  (add-hook 'lisp-mode-local-vars-hook #'sly-lisp-indent-compatibility-mode 'append)

    (progn
    (dolist (hook '(after-init-hook))
      (dolist
          (func
           (list
            (lambda (&rest _) (progn (with-eval-after-load 'sly (sly-setup))))))
        (add-hook hook func nil nil))))

  )

#+end_src

#+begin_src emacs-lisp :lexical t
(use-package sly-asdf
  :defer t
  :init
  (add-to-list 'sly-contribs 'sly-asdf 'append))
#+end_src
Нужен пакет quicklisp котрого нет в void 
#+begin_src emacs-lisp :lexical t
;; (use-package sly-quicklisp
;;   :after (sly)
;;   (require 'sly-quicklisp-autoloads)
;;   )

#+end_src
Как это настроить ?
#+begin_src emacs-lisp :lexical t :tangle no
(use-package sly-stepper
  :defer t
  :init
  (add-to-list 'sly-contribs 'sly-stepper))
#+end_src

#+begin_src emacs-lisp :lexical t
;;(use-package sly-macrostep )
#+end_src

#+begin_src emacs-lisp :lexical t
(use-package sly-repl-ansi-color
  :defer t
  :init
  (add-to-list 'sly-contribs 'sly-repl-ansi-color))
#+end_src

#+begin_src emacs-lisp :lexical t
(use-package sly-overlay
  :defer t)
#+end_src

* puni (replace paredit)

#+begin_src emacs-lisp :lexical t
(use-package puni
  :hook (((
           lisp-mode
           ) . puni-mode)
         (puni-mode . electric-pair-mode))
          )
  :preface
  (define-advice puni-kill-line (:before (&rest _) back-to-indentation)
    "Go back to indentation before killing the line if it makes sense to."
    (when (looking-back "^[[:space:]]*" nil)
      (if (bound-and-true-p indent-line-function)
          (funcall indent-line-function)
        (back-to-indentation))))
#+end_src

* ejc-sql 
Работает. 
#+begin_src emacs-lisp :lexical t :tangle yes
(use-package ejc-sql
  :defer t
  :commands ejc-sql-mode ejc-connect
  :config 
  ;(+eglot-register '(sql-mode) "sqls")
  (setq ejc-result-table-impl 'ejc-result-mode)
  (defun k/sql-mode-hook () (ejc-sql-mode t))
  (add-hook 'sql-mode-hook 'k/sql-mode-hook)

  (add-hook 'ejc-sql-connected-hook
            (lambda ()
              (ejc-set-column-width-limit 150)
              (ejc-set-fetch-size 120)
              (ejc-set-use-unicode t)))

  (defun sql/indent-tabs-mode ()
    (setq indent-tabs-mode nil))
  (add-hook 'sql-mode-hook #'sql/indent-tabs-mode)
  (ejc-create-connection
   "MariaDB-db-connection"
   :dependencies [[org.mariadb.jdbc/mariadb-java-client "2.6.0"]]
   :classname "org.mariadb.jdbc.Driver"
   :connection-uri "jdbc:mariadb://localhost:3306/sqlstepik"
   :user "root"
   :password "root"
   
   )
)

#+end_src

* TODO sql-mode
Eglot + sqls ?
#+begin_src emacs-lisp :lexical t
  ;; (use-feature sql
  ;;    :config
  ;;    (+eglot-register '(sql-mode) "sqls"))

#+end_src

* flycheck
#+begin_src emacs-lisp :lexical t 
(use-package flycheck
  :commands (flycheck-mode)
  :custom (flycheck-emacs-lisp-load-path 'inherit "necessary with alternatives to package.el"))
#+end_src
** flycheck-package
=package-lint= integration for flycheck.
#+begin_src emacs-lisp :lexical t
(use-package flycheck-package
  :after (flychceck)
  :config (flycheck-package-setup)
  (add-to-list 'display-buffer-alist
               '("\\*Flycheck errors\\*"  display-buffer-below-selected (window-height . 0.15))))
#+end_src
** flycheck-eglot
#+begin_src emacs-lisp :lexical t :tangle no
(use-package flycheck-eglot
  :after (flycheck eglot)
  :config
  (global-flycheck-eglot-mode 1))
#+end_src

* flymake
#+begin_src emacs-lisp :lexical t
(use-feature flymake
  :general
  (global-leader
    :major-modes '(emacs-lisp-mode lisp-interaction-mode t)
    :keymaps     '(emacs-lisp-mode-map lisp-interaction-mode-map)
    "f" '(:ignore t :which-key "flymake")
    "ff" '((lambda () (interactive) (flymake-mode 'toggle)) :which-key "toggle flymake-mode")
    "fn" 'flymake-goto-next-error
    "fp" 'flymake-goto-prev-error)
  ;; :hook (flymake-mode . (lambda () (or (ignore-errors flymake-show-project-diagnostics)
  ;;                                      (flymake-show-buffer-diagnostics))))
  :config
  (setq flymake-suppress-zero-counters nil)

  
  (add-to-list 'display-buffer-alist
               '("\\`\\*Flymake diagnostics.*?\\*\\'"
                 display-buffer-in-side-window  (window-parameters (window-height 0.25)) (side . bottom)))

  (defun +flymake-elpaca-bytecomp-load-path ()
    "Augment `elisp-flymake-byte-compile-load-path' to support Elpaca."
    (setq-local elisp-flymake-byte-compile-load-path
                `("./" ,@(mapcar #'file-name-as-directory
                                 (nthcdr 2 (directory-files (expand-file-name "builds" elpaca-directory) 'full))))))
  (add-hook 'flymake-mode-hook #'+flymake-elpaca-bytecomp-load-path))
#+end_src
* flyspell
#+begin_src emacs-lisp :lexical t :tangle no
(use-feature flyspell
  :commands (flyspell-mode flyspell-prog-mode)
  :general
  (+general-global-toggle
    "ss" 'flyspell-mode
    "sp" 'flyspell-prog-mode)
  (+general-global-spelling
    "n" 'flyspell-goto-next-error
    "b" 'flyspell-buffer
    "w" 'flyspell-word
    "r" 'flyspell-region)
  :hook ((org-mode mu4e-compose-mode git-commit-mode) . flyspell-mode))
#+end_src
** flyspell-correct
#+begin_quote
"This package provides functionality for correcting words via custom interfaces."
--
https://d12frosted.io/posts/2016-05-09-flyspell-correct-intro.html
#+end_quote

#+begin_src emacs-lisp :lexical t :tangle no
(use-package flyspell-correct
  :after (flyspell)
  :general
  (+general-global-spelling
    "B" 'flyspell-correct-wrapper
    "p" 'flyspell-correct-at-point))
#+end_src
* fvwm3
#+begin_src emacs-lisp :lexical t
(use-package fvwm-mode
  :ensure (fvwm-mode :host github :repo "theBlackDragon/fvwm-mode")
  :defer t
  :commands fvwm-mode )

  
#+end_src
* TODO ispell
Для cape-dict 
#+begin_src emacs-lisp :lexical t
(use-feature ispell
  :config
  (setq ispell-alternate-dictionary (file-truename "~/.config/emacs/dict/english-words.txt")))
#+end_src

* treemacs
#+begin_src emacs-lisp :lexical t
(use-package treemacs
  :defer t
  :bind
  (:map global-map
        ("M-0"       . treemacs-select-window)
        ("C-x t 1"   . treemacs-delete-other-windows)
        ("C-x t t"   . treemacs)
        ("C-x t d"   . treemacs-select-directory)
        ("C-x t B"   . treemacs-bookmark)
        ("C-x t C-t" . treemacs-find-file)
        ("C-x t M-t" . treemacs-find-tag))
  :custom
  (treemacs-sorting 'alphabetic-numeric-asc)
  :init
  ;; from doom
  (defun +treemacs/toggle ()
  "Initialize or toggle treemacs.

Ensures that only the current project is present and all other projects have
been removed.

Use `treemacs' command for old functionality."
  (interactive)
  (require 'treemacs)
  (pcase (treemacs-current-visibility)
    (`visible (delete-window (treemacs-get-local-window)))
    (_ (let ((project (treemacs--find-current-user-project)))
         (if (and project (not (file-equal-p project "~")))
             (treemacs-add-and-display-current-project-exclusively)
           (message "No valid project in current buffer; opening last treemacs session")
           (treemacs))))))
  )
#+end_src

** treemacs-evil
#+begin_src emacs-lisp :lexical t
(use-package treemacs-evil
  :after (treemacs evil)
  )
#+end_src

** treemacs-nerd-icons
#+begin_src emacs-lisp :lexical t
(use-package treemacs-nerd-icons
  :defer t
  :config
  (treemacs-load-theme "nerd-icons"))
#+end_src

** treemacs-magit
#+begin_src emacs-lisp :lexical t
(use-package treemacs-magit
  :after (treemacs magit)
  )
#+end_src
** treemacs-persp
#+begin_src emacs-lisp :lexical t :tangle no
(use-package treemacs-persp ;;treemacs-perspective if you use perspective.el vs. persp-mode
  :after (treemacs persp-mode) ;;or perspective vs. persp-mode
  :config (treemacs-set-scope-type 'Perspectives))
#+end_src
** treemacs-tab-bar
#+begin_src emacs-lisp :lexical t :tangle no
(use-package treemacs-tab-bar ;;treemacs-tab-bar if you use tab-bar-mode
  :after (treemacs)
  :config (treemacs-set-scope-type 'Tabs))
#+end_src

* org mode
#+begin_src emacs-lisp :lexical t
(use-package org
  :ensure (:autoloads "org-loaddefs.el")
  :hook ((org-mode . visual-line-mode)
         (org-mode . variable-pitch-mode))

  :defer t
  :general
  (general-define-key :states '(normal) :keymaps 'org-mode-map
                      (kbd "<tab>") 'org-cycle
                      (kbd "<backtab>") 'org-shifttab)
  (general-define-key :states '(normal insert) :keymaps 'org-mode-map
                      (kbd "M-l") 'org-metaright
                      (kbd "M-h") 'org-metaleft
                      (kbd "M-k") 'org-metaup
                      (kbd "M-j") 'org-metadown
                      (kbd "M-L") 'org-shiftmetaright
                      (kbd "M-H") 'org-shiftmetaleft
                      (kbd "M-K") 'org-shiftmetaup
                      (kbd "M-J") 'org-shiftmetadown
                      (kbd "C-M-<return>") 'org-insert-subheading)
  (general-define-key :states  '(motion) :keymaps 'org-mode-map
                      (kbd "RET") 'org-open-at-point)
  ;;<tab> is for GUI only. TAB maps to C-i on terminals.
  (+general-global-application
    "o"   '(:ignore t :which-key "org")
    "oc"  'org-capture
    "oC"  '+org-capture-again
    "oi"  'org-insert-link
    "oj"  'org-chronicle
    "ok"  '(:ignore t :which-key "clock")
    "okg" 'org-clock-goto
    "oki" 'org-clock-in-last
    "okj" 'org-clock-jump-to-current-clock
    "oko" 'org-clock-out
    "okr" 'org-resolve-clocks
    "ol"  'org-store-link
    "om"  'org-tags-view
    ;;"os"  'org-search-view
    "oT"  'org-todo-list
    "ot"  '(:ignore t :which-key "timer")
    "ott" 'org-timer
    "otS" 'org-timer-stop
    "otC" 'org-timer-change-times-in-region
    "otc" 'org-timer-set-timer
    "ots" 'org-timer-start
    "oti" 'org-timer-item
    "otp" 'org-timer-pause-or-continue
    "otr" 'org-timer-show-remaining-time)

  (global-leader
    ;;for terminals
    :keymaps '(org-mode-map)
    "TAB" 'org-cycle
    "."  'org-time-stamp
    "!"  'org-time-stamp-inactive
    "<"  'org-date-from-calendar
    ">"  'org-goto-calendar

    "C"  '(:ignore t :which-key "clock")
    "Cc" 'org-clock-cancel
    "Ci" 'org-clock-in
    "Co" 'org-clock-out
    "Cr" 'org-clock-report
    "CR" 'org-resolve-clocks

    "d"  '(:ignore t :which-key "dates")
    "dd" 'org-deadline
    "df" '((lambda () (interactive) (+org-fix-close-times))
           :which-key "org-fix-close-time")
    "ds" 'org-schedule
    "di" 'org-time-stamp-inactive
    "dt" 'org-time-stamp

    "e"   '(:ignore t :which-key "export")
    "ee"  'org-export-dispatch

    "h"   '(:ignore t :which-key "heading")
    "hf"  'org-forward-heading-same-level
    "hb"  'org-backward-heading-same-level

    "i"  '(:ignore t :which-key "insert")
    "id" 'org-insert-drawer
    "ie" 'org-set-effort
    "if" 'org-footnote-new
    "iH" 'org-insert-heading-after-current
    "ih" 'org-insert-heading
    "ii" 'org-insert-item
    "in" 'org-add-note
    "ip" 'org-set-property
    "is" 'org-insert-structure-template
    "it" 'org-set-tags-command

    "l" '(:ignore t :which-key "links")
    "lc" 'org-cliplink
    "ll" 'org-insert-link

    "n"  '(:ignore t :which-key "narrow")
    "nb" 'org-narrow-to-block
    "ne" 'org-narrow-to-element
    "ns" 'org-narrow-to-subtree
    "nt" 'org-toggle-narrow-to-subtree
    "nw" 'widen

    "s"  '(:ignore t :which-key "trees/subtrees")
    "sA" 'org-archive-subtree
    "sa" 'org-toggle-archive-tag
    "sb" 'org-tree-to-indirect-buffer
    "sc" 'org-cut-subtree
    "sh" 'org-promote-subtree
    "sj" 'org-move-subtree-down
    "sk" 'org-move-subtree-up
    "sl" 'org-demote-subtree
    "sp" '(:ignore t :which-key "priority")
    "spu" 'org-priority-up
    "spd" 'org-priority-down
    "sps" 'org-priority-show
    "sm" 'org-match-sparse-tree
    "sn" 'org-toggle-narrow-to-subtree
    "sr" 'org-refile
    "sS" 'org-sort
    "ss" '+org-sparse-tree

    "t"   '(:ignore t :which-key "tables")
    "ta"  'org-table-align
    "tb"  'org-table-blank-field
    "tc"  'org-table-convert

    "td"  '(:ignore t :which-key "delete")
    "tdc" 'org-table-delete-column
    "tdr" 'org-table-kill-row
    "tE"  'org-table-export
    "te"  'org-table-eval-formula
    "tH"  'org-table-move-column-left
    "th"  'org-table-previous-field
    "tI"  'org-table-import

    "ti"  '(:ignore t :which-key "insert")
    "tic" 'org-table-insert-column
    "tih" 'org-table-insert-hline
    "tiH" 'org-table-hline-and-move
    "tir" 'org-table-insert-row
    "tJ"  'org-table-move-row-down
    "tj"  'org-table-next-row
    "tK"  'org-table-move-row-up
    "tL"  'org-table-move-column-right
    "tl"  'org-table-next-field
    "tN"  'org-table-create-with-table.el
    "tn"  'org-table-create
    "tp"  'org-plot/gnuplot
    "tr"  'org-table-recalculate
    "ts"  'org-table-sort-lines

    "tt"  '(:ignore t :which-key "toggle")
    "ttf" 'org-table-toggle-formula-debugger
    "tto" 'org-table-toggle-coordinate-overlays
    "tw"  'org-table-wrap-region

    "T"  '(:ignore t :which-key "toggle")
    "Tc"  'org-toggle-checkbox
    "Te"  'org-toggle-pretty-entities
    "TE"  '+org-toggle-hide-emphasis-markers
    "Th"  'org-toggle-heading
    "Ti"  'org-toggle-item
    "TI"  'org-toggle-inline-images
    "Tl"  'org-toggle-link-display
    "TT"  'org-todo
    "Tt"  'org-show-todo-tree
    "Tx"  'org-latex-preview
    ;;"RET" 'org-ctrl-c-ret
    "RET" 'org-meta-return
    "#"   'org-update-statistics-cookies
    "'"   'org-edit-special
    "*"   'org-ctrl-c-star
    "-"   'org-ctrl-c-minus
    "A"   'org-attach)
  :config
  (setq org-tags-column -120) ;; так лучше 
  (setq org-link-frame-setup '((file . find-file))) ;; в org-ref это по дефолту
  (setq org-fontify-quote-and-verse-blocks t) ;; шрифт в comment и quote блоках. Почему в custom не работает ? 

  (defun +md-to-org-region (start end)
    "Convert region from markdown to org, replacing selection"
    (interactive "r")
    (shell-command-on-region start end "pandoc --wrap=none -f markdown -t org --lua-filter=/home/snake/custom-header.lua " t t))


  ;; (defun +md-to-org-region (start end)
  ;; "Convert region from markdown to org, replacing selection"
  ;; (interactive "r")
  ;; (save-excursion
  ;;   (delete-trailing-whitespace start end)
  ;;   (shell-command-on-region start end 
  ;;     "pandoc --wrap=none -f markdown -t org --lua-filter=/home/snake/custom-header.lua " 
  ;;     ;; t t)))

   (defun +org-align-all-tags ()
    "Wrap org-align-tags to be interactive and apply to all"
    (interactive)
    (org-align-tags t))

  (defun +org-sparse-tree (&optional arg type)
    (interactive)
    (funcall #'org-sparse-tree arg type)
    (org-remove-occur-highlights))

  (defun +insert-heading-advice (&rest _args)
    "Enter insert mode after org-insert-heading. Useful so I can tab to control level of inserted heading."
    (when evil-mode (evil-insert 1)))

  (advice-add #'org-insert-heading :after #'+insert-heading-advice)

  (defun +org-update-cookies ()
    (interactive)
    (org-update-statistics-cookies "ALL"))

  ;; Offered a patch to fix this upstream. Too much bikeshedding for such a simple fix.
  (defun +org-tags-crm (fn &rest args)
    "Workaround for bug which excludes \",\" when reading tags via `completing-read-multiple'.
  I offered a patch to fix this, but it was met with too much resistance to be
  worth pursuing."
    (let ((crm-separator "\\(?:[[:space:]]*[,:][[:space:]]*\\)"))
      (unwind-protect (apply fn args)
        (advice-remove #'completing-read-multiple #'+org-tags-crm))))

  (define-advice org-set-tags-command (:around (fn &rest args) comma-for-crm)
    (advice-add #'completing-read-multiple :around #'+org-tags-crm)
    (apply fn args))

  (add-to-list 'org-emphasis-alist
             '("*" (bold :foreground "#f1e00a")
               ("_" (underline :foreground "#c1d0a4")
               )))

  :custom
  ;;default:
  ;;(org-w3m org-bbdb org-bibtex org-docview org-gnus org-info org-irc org-mhe org-rmail)
  ;;org-toc is interesting, but I'm not sure if I need it.

  (org-modules '(org-habit))
  ;; 
  (org-todo-keywords
   ;; '((sequence  "TODO(t)" "STARTED(s!)" "NEXT(n!)" "BLOCKED(b@/!)" "|" "DONE(d)")
   ;;   (sequence  "IDEA(i)" "|" "CANCELED(c@/!)" "DELEGATED(D@/!)")
   ;;   (sequence  "RESEARCH(r)" "|"))
   '((sequence  "TODO(t)" "DONE(d)" )
     (sequence "DEPRECATED(o)"))
   ;;move to theme?
   org-todo-keyword-faces
   `(("CANCELED" . (:foreground "IndianRed1" :weight bold))
     ("TODO" . (:foreground "#ffddaa"
                            :weight bold
                            :background "#202020"
                            :box (:line-width 3 :width -2 :style released-button)))
     ("DEPRECATED" . (:foreground "yellow-faint" :weight bold))
     ))
  (org-ellipsis (nth 5 '("↴" "˅" "…" " ⬙" " ▽" "▿")))
  (org-priority-lowest ?D)
  (org-priority-faces '((?A . nerd-icons-red)
                        (?B . warning)
                        (?C . success)))
  (org-fontify-done-headline t)
  (org-insert-heading-respect-content t) ;; вставить новый хеадер с уважением к контенту !
  (org-M-RET-may-split-line nil "Don't split current line when creating new heading"))
#+end_src
* Выделение текста мышкой в болд
#+begin_src emacs-lisp :lexical t 
(defvar org-mouse-bold-mode nil
  "Флаг для включения/выключения выделения текста в режиме org.")

(define-advice mouse-set-region (:after (click) org-highlight ())
  (when (and org-mouse-bold-mode
             (derived-mode-p 'org-mode)
             (use-region-p))
    (let ((origin (buffer-substring (region-beginning) (region-end)))
          (emphasis-char "*"))
      (delete-region (region-beginning) (region-end))
      (insert emphasis-char origin emphasis-char))))

(defun org-mouse-bold-mode-enable ()
  "Включить режим выделения текста в режиме org."
  (interactive)
  (setq org-mouse-bold-mode t)
  (message "Режим выделения текста в режиме org включен."))

(defun org-mouse-bold-mode-disable ()
  "Выключить режим выделения текста в режиме org."
  (interactive)
  (setq org-mouse-bold-mode nil)
  (message "Режим выделения текста в режиме org выключен."))
#+end_src
* org-contrib(походу не надо это)
#+begin_src emacs-lisp :lexical t :tangle no
(use-package org-contrib)
#+end_src
* org-cliplink
#+begin_src emacs-lisp :lexical t
(use-package org-cliplink
  :defer t)
#+end_src
* org-modern
#+begin_src emacs-lisp :lexical t
(use-package org-modern
  :after (org)
  :config
  (global-org-modern-mode)
  (remove-hook 'org-agenda-finalize-hook 'org-modern-agenda)
  (setq org-modern-checkbox nil)
  (setq org-modern-star '("◉" "○" "✸" "✿" "✤" "✜" "◆" "▶")
        org-modern-block-name
        '((t . t)
          ("src" "»" "«")
          ("example" "»–" "–«")
          ("quote" "❝" "❞")
          ("export" "⏩" "⏪"))
        org-modern-block-fringe nil
        org-modern-progress nil ;;  ?
        org-modern-table nil ;; поломано
        org-modern-horizontal-rule (make-string 36 ?─) ;; что это дает ?
        org-modern-priority nil ;; не нашел годного
   ))
#+end_src
* auto-tangle-mode
#+begin_src emacs-lisp :lexical t
(use-package auto-tangle-mode
  :ensure (auto-tangle-mode
           :host github
           :repo "progfolio/auto-tangle-mode.el"
           :local-repo "auto-tangle-mode")
  :commands (auto-tangle-mode))
#+end_src

* TODO org-babel ob-tangle
 ob-js ob-python ob-shell возможно надо удалить el файлы и потом повторно ребилдить. 
use-package на use-feature для ob пакетов
#+begin_src emacs-lisp :lexical t
(use-feature ob-tangle
  :after (org)
  :ensure nil
  :custom
  (org-src-window-setup 'current-window)
  (org-src-preserve-indentation t)
  :general
  (global-leader :keymaps 'org-mode-map
    "b"   '(:ignore t :which-key "babel")
    "bt"  'org-babel-tangle
    "bT"  'org-babel-tangle-file
    "be"  '(:ignore t :which-key "execute")
    "beb" 'org-babel-execute-buffer
    "bes" 'org-babel-execute-subtree)
  :config
  (dolist (template '(("f" . "src fountain")
                    ("se" . "src emacs-lisp :lexical t")
                    ("ss" . "src shell")
                    ("sj" . "src javascript")))
  (add-to-list 'org-structure-template-alist template))
(use-feature ob-js
  :commands (org-babel-execute:js))
(use-feature ob-python
  :commands (org-babel-execute:python))
(use-feature ob-shell
  :commands (org-babel-execute:bash
             org-babel-execute:shell
             org-babel-expand-body:generic)
  :config (add-to-list 'org-babel-load-languages '(shell . t))
  (org-babel-do-load-languages 'org-babel-load-languages org-babel-load-languages))
                )

#+end_src
* org-roam
#+begin_src emacs-lisp :lexical t
(use-package org-roam
  :ensure (org-roam :host github :repo "org-roam/org-roam")
  :disabled t
  :general
  (+general-global-application
    "or" '(:ignore t :which-key "org-roam-setup"))
  :init (setq org-roam-v2-ack t))
#+end_src
* ox-gfm
#+begin_src emacs-lisp :lexical t
(use-package ox-gfm :defer t)
#+end_src
* ox-twbs
#+begin_quote
Export org-mode docs as HTML compatible with Twitter Bootstrap.

https://github.com/marsmining/ox-twbs
#+end_quote
#+begin_src emacs-lisp :lexical t
(use-package ox-twbs
  :disabled t
  :after (org)
  :defer t)
#+end_src

* olivetti
#+begin_quote
A simple Emacs minor mode for a nice writing environment.

https://github.com/rnkn/olivetti
#+end_quote
#+begin_src emacs-lisp :lexical t
(use-package olivetti
  :commands (olivetti-mode))
#+end_src
* org-agenda 
#+begin_src emacs-lisp :lexical t :tangle no
(use-feature org-agenda
  :after   (general evil)
  :config
  (defun +org-agenda-archives (&optional arg)
    "Toggle `org-agenda-archives-mode' so that it includes archive files by default.
  Inverts normal logic of ARG."
    (interactive "P")
    (let ((current-prefix-arg (unless (or org-agenda-archives-mode arg) '(4))))
      (call-interactively #'org-agenda-archives-mode)))

  (defun +org-agenda-place-point ()
    "Place point on first agenda item."
    (goto-char (point-min))
    (org-agenda-find-same-or-today-or-agenda))

  (add-hook 'org-agenda-finalize-hook #'+org-agenda-place-point 90)
  :general
  (+general-global-application
  "o#"   'org-agenda-list-stuck-projects
  "o/"   'org-occur-in-agenda-files
  "oa"   '((lambda () (interactive) (org-agenda nil "a")) :which-key "agenda")
  "oe"   'org-store-agenda-views
  "oo"   'org-agenda)
  (global-leader :keymaps 'org-mode-map
  "a"   'org-agenda)
;;Consider cribbing =evilified-state= from Spacemacs?

(with-eval-after-load 'org-agenda
  (evil-make-intercept-map org-agenda-mode-map)
  (general-define-key
   :keymaps 'org-agenda-mode-map
   ;;:states '(emacs normal motion)
   "A"     '+org-agenda-archives
   "C"     'org-agenda-clockreport-mode
   "D"     'org-agenda-goto-date
   "E"     'epoch-agenda-todo
   "H"     'org-habit-toggle-habits
   "J"     'org-agenda-next-item
   "K"     'org-agenda-previous-item
   "R"     'org-agenda-refile
   "S"     'org-agenda-schedule
   "RET"   'org-agenda-recenter
   "a"     '+org-capture-again
   "c"     'org-agenda-capture
   "j"     'org-agenda-next-line
   "k"     'org-agenda-previous-line
   "m"     'org-agenda-month-view
   "t"     'org-agenda-set-tags
   "T"     'org-agenda-todo
   "u"     'org-agenda-undo))
;;When saving, I want changes to my org-files reflected in any open org agenda
;;buffers.
  :config

;;for org-agenda-icon-alist
(evil-set-initial-state 'org-agenda-mode 'normal)
(defun +org-agenda-redo-all ()
  "Rebuild all agenda buffers"
  (interactive)
  (dolist (buffer (buffer-list))
    (with-current-buffer buffer
      (when (derived-mode-p 'org-agenda-mode)
        (org-agenda-maybe-redo)))))

(add-hook 'org-mode-hook
          (lambda ()
            (add-hook 'after-save-hook '+org-agenda-redo-all nil t)
            (setq prettify-symbols-unprettify-at-point 'right-edge)
            (setq prettify-symbols-alist
                  (mapcan (lambda (el) (list el (cons (upcase (car el)) (cdr el))))
                          '(("#+begin_src"     . "λ")
                            ("#+end_src"       . "λ")
                            (":properties:"    . "⚙")
                            (":end:"           . "∎")
                            ("#+results:"      . "→"))))
            (prettify-symbols-mode 1)))

  :custom
;; Add a custom view for a simplified work agenda.
(org-agenda-custom-commands
 '(("w" "Work Schedule" agenda "+work"
    ((org-agenda-files '("~/Documents/todo/work.org"))
     (org-agenda-span 'week)
     (org-mode-hook nil)
     (org-agenda-start-on-weekday 2)
     (org-agenda-timegrid-use-ampm t)
     (org-agenda-time-leading-zero t)
     (org-agenda-use-time-grid nil)
     (org-agenda-archives-mode t)
     (org-agenda-weekend-days '(2 3))
     (org-agenda-format-date "%a %m-%d")
     (org-agenda-prefix-format '((agenda . " %t")))
     (org-agenda-finalize-hook
      '((lambda ()
          "Format custom agenda command for work schedule."
          (save-excursion
            (goto-char (point-min))
            (while (re-search-forward "TODO Work" nil 'noerror)
              (replace-match ""))
            (goto-char (point-min))
            (forward-line) ;skip header
            (while (not (eobp))
              (when (get-text-property (point) 'org-agenda-date-header)
                (let (fn)
                  (save-excursion
                    (forward-line)
                    (setq fn
                          (cond ((or (eobp)
                                     (get-text-property (point) 'org-agenda-date-header))
                                 (lambda () (end-of-line) (insert " OFF")))
                                ((get-text-property (point) 'time)
                                 (lambda () (forward-line) (join-line))))))
                  (funcall fn)))
              (forward-line))))))))
   ("n" "Agenda and all TODOs" ((agenda "") (alltodo "")))))
(org-agenda-skip-deadline-prewarning-if-scheduled nil "Show approaching deadlines even when scheduled.")
;; I prefer the agenda to start on the current day view instead of the week. It's
;; generally faster to generate and usually what I want.
(org-agenda-span 'day)
;; These settings should speed up agenda generation:
(org-agenda-inhibit-startup t)
;; But, I'm not sure about this one. It doesn't seem to speed things up that much
;; for me and I like to see inherited tags on tasks.
(org-agenda-use-tag-inheritance nil)
;; I find category icons to be a nice visual shorthand that keeps the agenda less cluttered.
(org-agenda-prefix-format '((agenda . " %i %?-12t% s")))
(org-agenda-category-icon-alist
 (let ((image-dir (expand-file-name "images/org/" user-emacs-directory))
       (categories '(("[Aa]ccounting" "accounting.svg")
                     ("[Bb]irthday"   "birthday.svg")
                     ("[Cc]alendar"   "calendar.svg")
                     ("[Cc]hore"      "chore.svg"    :height 25)
                     ("[Ee]xercise"   "exercise.svg" :height 24)
                     ("[Ff]ood"       "food.svg")
                     ("[Hh]abit"      "habit.svg")
                     ("[Hh]ealth"     "health.svg")
                     ("[Ii]n"         "in.svg")
                     ("[Ll]isten"     "listen.svg")
                     ("[Oo]ut"        "out.svg")
                     ("[Pp]lay"       "play.svg")
                     ("[Rr]efile"     "refile.svg")
                     ("[Rr]ead"       "read.svg")
                     ("[Ww]atch"      "watch.svg")
                     ("[Ww]ork"       "work.svg"))))
   (mapcar (lambda (category)
             (list (nth 0 category)
                   (expand-file-name (nth 1 category) image-dir)
                   'svg
                   nil
                   :height (or (plist-get category :height) 20)
                   :ascent (or (plist-get category :ascent) 'center)))
           categories)))
;; This sorting strategy will place habits in/next to the agenda time-grid.
(org-agenda-sorting-strategy
 '((agenda time-up priority-down category-keep)
   (todo priority-down category-keep)
   (tags priority-down category-keep)
   (search category-keep)))

;; I want the agenda clock report table to skip files that don't have any time
;; clocked for the current agenda view.
(org-agenda-clockreport-parameter-plist
 '(:link t :maxlevel 2 :stepskip0 t :fileskip0 t))

;; I don't need to see the word "Scheduled" before scheduled items.
(org-agenda-scheduled-leaders '("" "%2dx "))

;; Align tags to column 80 in the agenda view:
(org-agenda-tags-column -80)

)

#+end_src
* org-capture
#+begin_src emacs-lisp :lexical t :tangle no
(use-feature org-capture
  :config
  (define-advice org-capture-fill-template (:around (fn &rest args) comma-for-crm)
    (advice-add #'completing-read-multiple :around #'+org-tags-crm)
    (apply fn args))
  (add-hook 'org-capture-mode-hook #'evil-insert-state)
;;Utility functions for use inside Org capture templates.
(defun +org-schedule-relative-to-deadline ()
  "For use with my appointment capture template. User is first prompted for an
  optional deadline. Then an optional schedule time. The scheduled default time is
  the deadline. This makes it easier to schedule relative to the deadline using
  the -- or ++ operators.

  Quitting during either date prompt results in an empty string for that prompt."
  (interactive)
  (condition-case nil
      (org-deadline nil)
    (quit nil))
  (let ((org-overriding-default-time (or (org-get-deadline-time (point))
                                         org-overriding-default-time)))
    (org-schedule nil (org-element-interpret-data
                       (org-timestamp-from-time
                        org-overriding-default-time
                        (and org-overriding-default-time 'with-time))))
    (let ((org-log-reschedule nil))
      (condition-case nil
          (org-schedule nil)
        (quit (org-schedule '(4)))))))

(defun +org-capture-again (&optional arg)
  "Call `org-capture' with last selected template.
  Pass ARG to `org-capture'.
  If there is no previous template, call `org-capture'."
  (interactive "P")
  (org-capture arg (plist-get org-capture-plist :key)))

(defun +org-capture-here ()
  "Convenience command to insert a template at point"
  (interactive)
  (org-capture 0))

(defun +org-capture-property-drawer ()
  "Hook function run durning `org-capture-mode-hook'.
  If a template has a :properties keyword, add them to the entry."
  (when (eq (org-capture-get :type 'local) 'entry)
    (when-let ((properties (doct-get :properties t)))
      (dolist (property properties)
        (org-set-property
         (symbol-name (car property))
         (replace-regexp-in-string
          "\n.*" ""
          (org-capture-fill-template
           (doct--replace-template-strings (cadr property)))))))))

(defun +org-capture-todo ()
  "Set capture entry to TODO automatically"
  (org-todo "TODO"))

(setq org-capture-templates
      (doct `(("Appointment"
               :keys "a"
               :id "2cd2f75e-b600-4e9b-95eb-6baefeaa61ac"
               :properties ((Created "%U"))
               :template ("* %^{appointment} %^g" "%?")
               :hook (lambda ()
                       (+org-capture-property-drawer)
                       (unless org-note-abort (+org-schedule-relative-to-deadline))))
              ("Account"
               :keys "A"
               :properties ((Created "%U"))
               :template ("* TODO %^{description} %^g" "%?")
               :hook +org-capture-property-drawer
               :children (("Buy"
                           :keys "b"
                           :id "e1dcca6e-6d85-4c8e-b935-d50492b2cc58")
                          ("Borrow"
                           :keys "B"
                           :id "a318b8ba-ed1a-4767-84bd-4f45eb409aab"
                           :template ("* TODO Return %^{description} to %^{person} %^g"
                                      "DEADLINE: %^T"
                                      "%?"))
                          ("Loan"
                           :keys "l"
                           :id "cfdd301d-c437-4aae-9738-da022eae8056"
                           :template ("* TODO Get %^{item} back from %^{person} %^g"
                                      "DEADLINE: %^T"
                                      "%?"))
                          ("Favor"
                           :keys "f"
                           :id "9cd02444-2465-4692-958b-f73edacd997f")
                          ("Sell"
                           :keys "s"
                           :id "9c4a39c5-3ba6-4665-ac43-67e72f461c15")))
              ("Bookmark"
               :keys "b"
               :hook +org-capture-property-drawer
               :id "7c20c705-80a3-4f5a-9181-2ea14a18fa75"
               :properties ((Created "%U"))
               :template ("* [[%x][%^{title}]] %^g" "%?"))
              ("Health"
               :keys "h"
               :children (("Blood Pressure"
                           :keys "b"
                           :type table-line
                           :id "4d0c16dd-ce99-4e1b-bf9f-fb10802e48a1"
                           :template "%(+compute-blood-pressure-table-row)|%?|"
                           :table-line-pos "II-1")))
              ("Listen"
               :keys "l"
               :hook (lambda () (+org-capture-property-drawer) (+org-capture-todo))
               :template ("* TODO %^{Title} %^g" "%^{Genre}")
               :children (("Audio Book"
                           :keys "a"
                           :id "55a01ad5-24f5-40ec-947c-ed0bc507d4e8"
                           :template "* TODO %^{Title} %^g %^{Author}p %^{Year}p %^{Genre}p")
                          ("Music"
                           :keys "m"
                           :id "dc9cfb0f-c65b-4ebe-a082-e751bb3261a6"
                           :template "%(wikinforg-capture \"album\")")
                          ("Podcast"
                           :keys "p"
                           :id "881ee183-37aa-4e76-a5af-5be8446fc346"
                           :properties ((URL "[[%^{URL}][%^{Description}]]")))
                          ("Radio"
                           :keys "r"
                           :id "78da1d3e-c83a-4769-9fb2-91e8ff7ab5da")))
              ("Note"
               :keys "n"
               :file ,(defun +org-capture-repo-note-file ()
                        "Find note for current repository."
                        (require 'projectile)
                        (let* ((coding-system-for-write 'utf-8)
                               ;;@MAYBE: extract this to a global variable.
                               (notedir "~/Documents/devops/repo-notes/")
                               (project-root (projectile-project-root))
                               (name (concat (file-name-base (directory-file-name project-root)) ".org"))
                               (path (expand-file-name name (file-truename notedir))))
                          (with-current-buffer (find-file-noselect path)
                            (unless (derived-mode-p 'org-mode) (org-mode)
                                    ;;set to utf-8 because we may be visiting raw file
                                    (setq buffer-file-coding-system 'utf-8-unix))
                            (when-let ((headline (doct-get :headline)))
                              (unless (org-find-exact-headline-in-buffer headline)
                                (goto-char (point-max))
                                (insert "* " headline)
                                (org-set-tags (downcase headline))))
                            (unless (file-exists-p path) (write-file path))
                            path)))
               :template (lambda () (concat  "* %{todo-state} " (when (y-or-n-p "Link? ") "%A\n") "%?"))
               :todo-state "TODO"
               :children (("bug" :keys "b" :headline "Bug")
                          ("design"        :keys "d" :headline "Design")
                          ("documentation" :keys "D" :headline "Documentation")
                          ("enhancement"   :keys "e" :headline "Enhancement" :todo-state "IDEA")
                          ("feature"       :keys "f" :headline "Feature"     :todo-state "IDEA")
                          ("optimization"  :keys "o" :headline "Optimization")
                          ("miscellaneous" :keys "m" :headline "Miscellaneous")
                          ("security"      :keys "s" :headline "Security")))
              ("Play"
               :keys "p"
               :id "be517275-3779-477f-93cb-ebfe0204b614"
               :hook +org-capture-todo
               :template "%(wikinforg-capture \"game\")")
              ("Read"
               :keys "r"
               :template "%(wikinforg-capture \"book\")"
               :hook +org-capture-todo
               :children (("fiction"
                           :keys "f"
                           :id "0be106fc-a920-4ab3-8585-77ce3fb793e8")
                          ("non-fiction"
                           :keys "n"
                           :id "73c29c94-fb19-4012-ab33-f51158c0e59b")))
              ("Say"
               :keys "s"
               :children (("word" :keys "w"
                           :id "55e43a15-5523-49a6-b16c-b6fbae337f05"
                           :template ("* %^{Word}" "%?"))
                          ("Phrase" :keys "p"
                           :id "c3dabe22-db69-423a-9737-f90bfc47238a"
                           :template ("* %^{Phrase}" "%?"))
                          ("Quote" :keys "q"
                           :id "8825807d-9662-4d6c-a28f-6392d3c4dbe2"
                           :template ("* %^{Quote}" "%^{Quotee}p"))))
              ("Todo" :keys "t"
               :id "0aeb95eb-25ee-44de-9ef5-2698514f6208"
               :hook (lambda ()
                       (+org-capture-property-drawer)
                       ;;swallow org-todo quit so we don't abort the whole capture
                       (condition-case nil (org-todo) (quit nil)))
               :properties ((Created "%U"))
               :template ("* %^{description} %^g" "%?"))
              ("use-package" :keys "u"
               :file ,(expand-file-name "init.org" user-emacs-directory)
               :function
               ,(defun +org-capture-use-package-form ()
                  "place point for use-package capture template."
                  (org-fold-show-all)
                  (goto-char (org-find-entry-with-id "f8affafe-3a4c-490c-a066-006aeb76f628"))
                  (org-narrow-to-subtree)
                  ;;popping off parent headline, evil and general.el since they are order dependent.
                  (when-let* ((name (read-string "package name: "))
                              (headlines (nthcdr 4 (caddr (org-element-parse-buffer 'headline 'visible))))
                              (packages (mapcar (lambda (headline) (cons (plist-get (cadr headline) :raw-value)
                                                                         (plist-get (cadr headline) :contents-end)))
                                                headlines))
                              (target (let ((n (downcase name)))
                                        (cdr
                                         (cl-some (lambda (package) (and (string-greaterp n (downcase (car package))) package))
                                                  (nreverse packages))))))
                    ;;put name on template's doct plist
                    (setq org-capture-plist
                          (plist-put org-capture-plist :doct
                                     (plist-put (org-capture-get :doct) :use-package name)))
                    (goto-char target)
                    (org-end-of-subtree)
                    (open-line 1)
                    (forward-line 1)))
               :type plain
               :empty-lines-after 1
               :template ("** %(doct-get :use-package)"
                          "#+begin_quote"
                          "%(read-string \"package description:\")"
                          "#+end_quote"
                          "#+begin_src emacs-lisp"
                          "(use-package %(doct-get :use-package)%?)"
                          "#+end_src"))

              ("Watch":keys "w"
               :template "%(wikinforg-capture \"%{entity}\")"
               :hook +org-capture-todo
               :children (("Film" :keys "f" :id "a730a2db-7033-40af-82c1-9b73528ab7d9" :entity "film")
                          ("TV" :keys "t" :id "4a18a50e-909e-4d36-aa7a-b09e8c3b01f8" :entity "show")
                          ("Presentation" :keys "p" :id "343fe4f4-867a-4033-b31a-8b57aba0345e"
                           :template "* %^{Title} %^g %^{Year}p"))))))

;; =make-capture-frame= cobbled together from:
;; - http://cestlaz.github.io/posts/using-emacs-24-capture-2/
;; - https://stackoverflow.com/questions/23517372/hook-or-advice-when-aborting-org-capture-before-template-selection
;; Don't use this within Emacs. Rather, invoke it when connecting an Emacs client to a server with:
;;emacsclient --create-frame \
;;            --socket-name 'capture' \
;;            --alternate-editor='' \
;;            --frame-parameters='(quote (name . "capture"))' \
;;            --no-wait \
;;            --eval "(+org-capture-make-frame)"

(defun +org-capture-delete-frame (&rest _args)
  "Delete frame with a name frame-parameter set to \"capture\""
  (when (and (daemonp) (string= (frame-parameter (selected-frame) 'name) "capture"))
    (delete-frame)))
(add-hook 'org-capture-after-finalize-hook #'+org-capture-delete-frame 100)

(defun +org-capture-make-frame ()
  "Create a new frame and run org-capture."
  (interactive)
  (select-frame-by-name "capture")
  (delete-other-windows)
  (cl-letf (((symbol-function 'switch-to-buffer-other-window) #'switch-to-buffer))
    (condition-case err
        (org-capture)
      ;; "q" signals (error "Abort") in `org-capture'
      ;; delete the newly created frame in this scenario.
      (user-error (when (string= (cadr err) "Abort") (delete-frame))))))

:commands (+org-capture-make-frame)
:general
(:states 'normal
         :keymaps 'org-capture-mode-map
         ",c" 'org-capture-finalize
         ",k" 'org-capture-kill
         ",r" 'org-capture-refile)
:custom
(org-capture-dir (concat (getenv "HOME") "/Documents/todo/")))
#+end_src
* org-clean-refile 
#+begin_src emacs-lisp :lexical t :tangle no
(use-package org-clean-refile
  :elpaca (org-clean-refile :host github :repo "progfolio/org-clean-refile" :protocol ssh)
  :commands (org-clean-refile)
  :after (org)
  :general
  (global-leader
    :keymaps 'org-mode-map
    "sr" 'org-clean-refile))
#+end_src
* [#B] org-fancy-priorities

#+begin_src emacs-lisp :lexical t
(use-package org-fancy-priorities
  :commands (org-fancy-priorities-mode)
  :hook (org-mode . org-fancy-priorities-mode)
  :diminish ""
  :config
  (setq org-fancy-priorities-list '("⚑" "⬆" "■"))
  )
#+end_src
* org-habit
#+begin_src emacs-lisp :lexical t
(use-feature org-habit
  :after (org)
  :config
  (defun +org-habit-graph-on-own-line (graph)
    "Place org habit consitency graph below the habit."
    (let* ((count 0)
           icon)
      (save-excursion
        (beginning-of-line)
        (while (and (eq (char-after) ? ) (not (eolp)))
          (when (get-text-property (point) 'display) (setq icon t))
          (setq count (1+ count))
          (forward-char)))
      (add-text-properties (+ (line-beginning-position) count) (line-end-position)
                           `(display ,(concat (unless icon "  ")
                                              (string-trim-left (thing-at-point 'line))
                                              (make-string (or org-habit-graph-column 0) ? )
                                              (string-trim-right
                                               (propertize graph 'mouse-face 'inherit)))))))
;; I've submitted a [[https://orgmode.org/list/87h7sx5f5z.fsf@gmail.com/T/#t][patch]] to customize consistency graph placement in the agenda.
;; Rather than constantly rebase my patch on top of the latest Org, I'm adding advice
;; to override the default placement.

  (defun +org-habit-insert-consistency-graphs (&optional line)
  "Insert consistency graph for any habitual tasks."
  (let ((inhibit-read-only t)
        (buffer-invisibility-spec '(org-link))
        (moment (time-subtract nil (* 3600 org-extend-today-until))))
    (save-excursion
      (goto-char (if line (line-beginning-position) (point-min)))
      (while (not (eobp))
        (let ((habit (get-text-property (point) 'org-habit-p)))
          (when habit
            (let ((graph (org-habit-build-graph
                          habit
                          (time-subtract moment (days-to-time org-habit-preceding-days))
                          moment
                          (time-add moment (days-to-time org-habit-following-days)))))
              (+org-habit-graph-on-own-line graph))))
        (forward-line)))))

        (advice-add #'org-habit-insert-consistency-graphs
  :override #'+org-habit-insert-consistency-graphs)

  :custom
  (org-habit-today-glyph #x1f4c5)
  (org-habit-completed-glyph #x2713)
  (org-habit-preceding-days 29)
  (org-habit-following-days 1)
  (org-habit-graph-column 3)
  (org-habit-show-habits-only-for-today nil)

  (integerp nil))
#+end_src
* org-indent
#+begin_src emacs-lisp :lexical t
(use-feature org-indent
  :diminish ""
  :after (org)
  :hook (org-mode . org-indent-mode)
  :config
  (define-advice org-indent-refresh-maybe (:around (fn &rest args) "when-buffer-visible")
    "Only refresh indentation when buffer's window is visible.
Speeds up `org-agenda' remote operations."
    (when (get-buffer-window (current-buffer) t) (apply fn args))))
#+end_src
** [#B] refile
This function allows me to refile within the currently open org files
as well as agenda files. Useful for structural editing.
Stolen from: [[https://emacs.stackexchange.com/questions/22128/how-to-org-refile-to-a-target-within-the-current-file?rq=1][stackoverflow: how to org-refile to a target within the current file?]]
#+begin_src emacs-lisp :lexical t
(defun +org-files-list ()
  "Returns a list of the file names for currently open Org files"
  (delq nil
        (mapcar (lambda (buffer)
                  (when-let* ((file-name (buffer-file-name buffer))
                              (directory (file-name-directory file-name)))
                    (unless (string-suffix-p "archives/" directory)
                      file-name)))
                (org-buffer-list 'files t))))
#+end_src

#+begin_src emacs-lisp :lexical t
(setq +org-max-refile-level 20)
(setq org-outline-path-complete-in-steps nil
      org-refile-allow-creating-parent-nodes 'confirm
      org-refile-use-outline-path 'file
      org-refile-targets `((org-agenda-files  :maxlevel . ,+org-max-refile-level)
                           (+org-files-list :maxlevel . ,+org-max-refile-level)))
#+end_src
* Org mode settings 
#+begin_src emacs-lisp :lexical t
(setq org-agenda-files '("~/OrgFiles/TODO.org")
      org-directory "~/OrgFiles"
      org-agenda-text-search-extra-files '(agenda-archives)
      org-fold-catch-invisible-edits 'show-and-error
      org-confirm-babel-evaluate nil
      org-enforce-todo-dependencies t
      org-hide-emphasis-markers t
      org-hierarchical-todo-statistics nil
      org-startup-folded 'fold
      org-log-done 'time
      org-log-reschedule t
      org-return-follows-link t
      org-reverse-note-order t
      org-src-tab-acts-natively t
      org-file-apps
      '((auto-mode . emacs)
        ("\\.mm\\'" . default)
        ("\\.mp[[:digit:]]\\'" . "/usr/bin/mpv --force-window=yes %s")
        ;;("\\.x?html?\\'" . "/usr/bin/firefox-beta %s")
        ("\\.x?html?\\'" . "/usr/bin/bash -c '$BROWSER  %s'")
        ("\\.pdf\\'" . default)))
#+end_src
Set clock report duration format to floating point hours
#+begin_src emacs-lisp :lexical t
;;(setq org-duration-format  '(h:mm))
(setq org-duration-format '(("h" . nil) (special . 2)))
#+end_src
* Org mode colors
#+begin_src emacs-lisp :lexical t
#+end_src
* org-make-toc
#+begin_src emacs-lisp :lexical t
(use-package org-make-toc
  :commands (org-make-toc))
#+end_src
* org-mime
#+begin_quote
org-mime can be used to send HTML email using Org-mode HTML export.

https://github.com/org-mime/org-mime
#+end_quote
#+begin_src emacs-lisp :lexical t
(use-package org-mime
  :after (org)
  :commands (org-mime-htmlize
             org-mime-org-buffer-htmlize
             org-mime-org-subtree-htmlize)
  :config
  (setq org-mime-export-options '( :with-latex dvipng
                                   :section-numbers nil
                                   :with-author nil
                                   :with-toc nil)))
#+end_src

* org-pandoc
#+begin_src emacs-lisp :lexical t
(use-package org-pandoc-import
 :ensure (org-pandoc-import :host github :repo "tecosaur/org-pandoc-import" :files ("*.el" "filters" "preprocessors"))
 :defer t
 :after (org))
#+end_src

* org-download
В emacs 29 добавили yank-media. Может это все должно быть как-то вокруг org-attach настроено ?
Странно, что в doom org-download-image-dir работал. Может потому что там setq! как-то хитро настроено.
[[https://emacs.stackexchange.com/questions/75983/how-to-format-org-downloads-image-saving-directorys][org mode - How to format org-download's image saving directory(s)? - Emacs St...]] это помогло решить. хотя в этом коде есть микро ошибка.
[[https://github.com/abo-abo/org-download/issues/195][abo-abo/org-download#195 Syntax to create subdirectories for each org file: (...]] не знаю что тут.

#+attr_org: :width 600px
[[file:/home/snake/.config/emacs/org-download/2024-09-04_18-58-31_screenshot.png]]

#+begin_src emacs-lisp :lexical t
(use-package org-download
  :after org 
  ;; :hook (
  ;;        (org-mode . org-download-enable)
  ;;        (org-mode . my-org-download-set-dir)
  ;;        )
  :custom
  (org-download-method 'directory)
  (org-download-image-org-width 600)
  (org-download-link-format "[[file:%s]]\n")
  (org-download-abbreviate-filename-function #'expand-file-name)
  (org-download-link-format-function #'org-download-link-format-function-default)
  :config
  (setq org-download-annotate-function (lambda (_link) "")) ;; #+Downloaded
  ;; (defun my-org-download-set-dir ()
  ;;   "Set `org-download-image-dir` to the directory of the current 
  ;;       buffer's file."
  ;;   (setq-local org-download-image-dir (concat (file-name-sans-extension (buffer-file-name)) "-img"))))

  (defun +my-org-download-set-dir ()
    (interactive) ;; TODO temp fix 
    "Set `org-download-image-dir` to an Images subdirectory in the current file's directory."
    (let* ((filename (buffer-file-name))
           (file-dir (file-name-directory filename))
           (file-name (file-name-nondirectory (file-name-sans-extension filename)))
           (images-dir (expand-file-name "Attachments" file-dir)))
      (setq-local org-download-image-dir 
                  (expand-file-name (concat file-name "-img") images-dir))))
  )
  
#+end_src

* org-appear
#+begin_src emacs-lisp :lexical t
(use-package org-appear
  :hook ((org-mode . org-appear-mode)
         (org-roam-mode . org-appear-mode))
  :config
  (setq org-appear-autoemphasis t
        org-appear-autosubmarkers t
        org-appear-autolinks nil)
  ;; for proper first-time setup, `org-appear--set-elements'
  ;; needs to be run after other hooks have acted.
  (run-at-time nil nil #'org-appear--set-elements))

#+end_src

* doct
#+begin_src emacs-lisp :lexical t
(use-package doct
  :defer t
  :commands (doct))
#+end_src

* vterm
#+begin_src emacs-lisp :lexical t
(use-package vterm
  :ensure (vterm :post-build
                 (progn
                   (setq vterm-always-compile-module t)
                   (require 'vterm)
                   ;;print compilation info for elpaca
                   (with-current-buffer (get-buffer-create vterm-install-buffer-name)
                     (goto-char (point-min))
                     (while (not (eobp))
                       (message "%S"
                                (buffer-substring (line-beginning-position)
                                                  (line-end-position)))
                       (forward-line)))
                   (when-let ((so (expand-file-name "./vterm-module.so"))
                              ((file-exists-p so)))
                     (make-symbolic-link
                      so (expand-file-name (file-name-nondirectory so)
                                           "../../builds/vterm")
                      'ok-if-already-exists))))
  :commands (vterm vterm-other-window)
  :general
  (+general-global-open
    ;;"t" '(:ignore t :which-key "terminal")
    "T" 'vterm-other-window
    "t" 'vterm)
  ;; :config
  ;; (evil-set-initial-state 'vterm-mode 'emacs)
  :init
  (add-to-list 'evil-insert-state-modes #'vterm-mode)
  )
#+end_src

* TODO diminish
Удалить ?
#+begin_src emacs-lisp :lexical t
(use-package diminish
  :defer 10)
#+end_src
* winner
#+begin_src emacs-lisp :lexical t
(use-feature winner
  :defer 5
  :general
  (+general-global-window
    "u" 'winner-undo
    "r" 'winner-redo)
  :config (winner-mode))
#+end_src
* yasnippets (заменить на tempel)
#+begin_src emacs-lisp :lexical t
(use-package yasnippet
  :commands (yas-global-mode)
  :custom
  (yas-snippet-dirs '("~/.config/emacs/elpaca/repos/snippets")))
#+end_src
* doom-snippets
#+begin_src emacs-lisp :lexical t
  (use-package doom-snippets
  :ensure (doom-snippets :host github :repo "doomemacs/snippets" :files ("*.el" "*"))
  ;;:load-path "~/.config/vanilla/snippets"
  :after yasnippet)
#+end_src
* tramp
#+begin_src emacs-lisp :lexical t
(use-feature tramp
  :defer t
  :custom (tramp-terminal-type "tramp")
  :config (setq debug-ignored-errors (cons 'remote-file-error debug-ignored-errors)))
#+end_src
* vc-hooks
You probably want this 99% of the time and it will skip an annoying prompt.
#+begin_src emacs-lisp :lexical t
(use-feature vc-hooks
  :custom
  (vc-follow-symlinks t "Visit real file when editing a symlink without prompting."))
#+end_src

* dictionary
#+begin_src emacs-lisp :lexical t :tangle no
(use-feature dictionary
  :general
  (global-definer "W" 'dictionary-lookup-definition)
  (+general-global-application "D" 'dictionary-search)
  (+general-global-text "d" 'dictionary-search))
#+end_src
* tern (build fails) 
#+begin_quote
Tern is a stand-alone, editor-independent JavaScript analyzer that can be used to improve the JavaScript integration of existing editors.

https://github.com/ternjs/tern
#+end_quote
#+begin_src emacs-lisp :lexical t :tangle no
(use-package tern
  :disabled t
  :commands (tern-mode)
  :hook (js2-mode . tern-mode))
#+end_src
* time (Не используем)
I like to see the date and time in my mode line.
I use doom-modeline for the rest of my mode line configuration.
#+begin_src emacs-lisp :lexical t :tangle no
(use-feature time
  :custom
  (display-time-day-and-date t "Show date, day, and time")
  :config
  (display-time))
#+end_src

* window 
#+begin_src emacs-lisp :lexical t
(use-feature window
  :bind (("C-x 2" . vsplit-last-buffer)
         ("C-x 3" . hsplit-last-buffer))
  :preface
  (defun hsplit-last-buffer ()
    "Focus to the last created horizontal window."
    (interactive)
    (split-window-horizontally)
    (other-window 1))

  (defun vsplit-last-buffer ()
    "Focus to the last created vertical window."
    (interactive)
    (split-window-vertically)
    (other-window 1))
  :custom
  (switch-to-buffer-obey-display-actions t)
  (switch-to-prev-buffer-skip-regexp
   '("\\*Help\\*" "\\*Calendar\\*" "\\*mu4e-last-update\\*"
     "\\*Messages\\*" "\\*scratch\\*" "\\magit-.*")))
#+end_src

* TODO Папка с кешем eln
#+begin_src emacs-lisp :lexical t
;;; Emacs 28+ (native-comp) stuff
;; (when (and (fboundp 'native-comp-available-p) (native-comp-available-p))
;;   (progn
;;     (setq native-comp-async-report-warnings-errors nil)
;;     (setq native-comp-deferred-compilation t)
;;     (add-to-list 'native-comp-eln-load-path (expand-file-name "eln-cache/" user-emacs-directory))
;;     (setq package-native-compile t)))

#+end_src
* package-lint
#+begin_src emacs-lisp :lexical t
(use-package package-lint
  :defer t
  :commands (package-lint-current-buffer +package-lint-elpaca)
  :config
;; package-lint assumes package.el is the package manager.
;; I use elpaca.el, so I get spurious warnings about uninstallable packages.
;; This workaround creates a temporary package archive and enables package.el to appease package-lint.

  (defun +package-lint-elpaca ()
  "Help package-lint deal with elpaca."
  (interactive)
  (require 'package)
  (setq package-user-dir "/tmp/elpa")
  (add-to-list 'package-archives '("melpa" . "https://melpa.org/packages/") t)
  (package-initialize)
  (package-refresh-contents))

(+package-lint-elpaca))
#+end_src
* paren
Подсветка пар скобок {} []
#+begin_src emacs-lisp :lexical t
(use-feature paren
  :defer 1
  :config (show-paren-mode))
#+end_src
* project.el
#+begin_src emacs-lisp :lexical t :tangle yes
(use-feature project
  :config
  (add-to-list 'project-switch-commands '(+project-magit-status "Magit" "m"))
  (add-to-list 'project-switch-commands '(consult-ripgrep "Ripgrep" "F"))
  :custom
  (project-vc-extra-root-markers
   '(".projectile.el" ".project.el" ".project" ; Emacs
     ".repo" ; Repo workspaces
     "autogen.sh" ; Autotools
     ".dir-locals.el"
     "*.csproj" "*.vbproj" "*.vcxproj" "*.vdproj" ".code-workspace" ; Visual Studio
     "requirements.txt" ; Python
     "package.json" ; Node.js
     "pom.xml" ; Apache Maven (Java/Kotlin)
     "gradlew" "build.gradle.kts"
     "Cargo.toml")) ; Cargo (Rust)
  :init
  (defun +project-magit-status ()
  (interactive)
  (magit-status (project-root (project-current))))
)
#+end_src
* pdf-tools

#+begin_src emacs-lisp :lexical t :tangle no
(use-package pdf-tools
  :ensure (pdf-tools :pre-build ("./server/autobuild") :files (:defaults "server/epdfinfo"))
  :functions (pdf-isearch-batch-mode)
  :commands (pdf-tools-install pdf-view-mode)
 ;; :custom (pdf-view-midnight-colors '("#AFA27C" . "#0F0E16"))
  :config (add-hook 'pdf-view-mode-hook
                    (lambda ()
                      ;; get rid of borders on pdf's edges
                      (set (make-local-variable 'evil-normal-state-cursor) (list nil))
                      ;;for fast i-search in pdf buffers
                      (pdf-isearch-minor-mode)
                      (pdf-isearch-batch-mode)
                      ;;(pdf-view-dark-minor-mode)
                      ;;(pdf-view-midnight-minor-mode)
                      )
                    )
  :mode (("\\.pdf\\'" . pdf-view-mode)))
#+end_src
John Wiegley
#+begin_src emacs-lisp :lexical t :tangle no
(use-package pdf-tools
  ;;:ensure (pdf-tools :pre-build ("./server/autobuild") :files (:defaults "server/epdfinfo"))
  ;;:commands (pdf-tools-install pdf-view-mode)
  :custom (pdf-view-midnight-colors '("#AFA27C" . "#0F0E16"))
  :config (add-hook 'pdf-view-mode-hook
                    (lambda ()
                      ;; get rid of borders on pdf's edges
                      (set (make-local-variable 'evil-normal-state-cursor) (list nil))
                      ;;for fast i-search in pdf buffers
                      (pdf-isearch-minor-mode)
                      (pdf-isearch-batch-mode)
                      (pdf-view-dark-minor-mode)
                      (pdf-view-midnight-minor-mode)))
  :magic ("%PDF" . pdf-view-mode)
  )
#+end_src
* image-roll
#+begin_src emacs-lisp :lexical t
;; (use-package image-roll
;;   :ensure (image-roll :host github :repo "dalanicolai/image-roll.el")
;;   :defer t)
#+end_src

* pass
** pass.el
#+begin_src emacs-lisp :lexical t
(use-package pass
  :defer t
  :commands (pass pass-view-mode)
  :mode ("\\.password-store/.*\\.gpg\\'" . pass-view-mode)
  :preface
  (defun insert-password ()
    (interactive)
    ;;(shell-command "apg -m24 -x24 -a1 -n1" t))
    (shell-command "gpg --gen-random --armor 1 14" t))

  (add-hook 'pass-view-mode-hook #'pass-view--prepare-otp))

#+end_src

** auth-source-pass (built-in)
#+begin_src emacs-lisp :lexical t
(use-feature auth-source-pass
  :preface
  (defvar auth-source-pass--cache (make-hash-table :test #'equal))

  (defun auth-source-pass--reset-cache ()
    (setq auth-source-pass--cache (make-hash-table :test #'equal)))

  (defun auth-source-pass--read-entry (entry)
    "Return a string with the file content of ENTRY."
    (run-at-time 45 nil #'auth-source-pass--reset-cache)
    (let ((cached (gethash entry auth-source-pass--cache)))
      (or cached
          (puthash
           entry
           (with-temp-buffer
             (insert-file-contents (expand-file-name
                                    (format "%s.gpg" entry)
                                    (getenv "PASSWORD_STORE_DIR")))
             (buffer-substring-no-properties (point-min) (point-max)))
           auth-source-pass--cache))))

  (defun auth-source-pass-entries ()
    "Return a list of all password store entries."
    (let ((store-dir (getenv "PASSWORD_STORE_DIR")))
      (mapcar
       (lambda (file) (file-name-sans-extension (file-relative-name file store-dir)))
       (directory-files-recursively store-dir "\.gpg$"))))
  :config
  (auth-source-pass-enable))
#+end_src

** password-store
#+begin_src emacs-lisp :lexical t
(use-package password-store
  :defer t
  :commands (password-store-insert
             password-store-copy
             password-store-get)
  :custom
  (password-store-password-length 14) ;; или 24 
  :functions (password-store--run)
  :config
  (defun password-store--run-edit (entry)
    (require 'pass)
    (find-file (concat (expand-file-name entry (password-store-dir)) ".gpg")))

  (defun password-store-insert (entry login password)
    "Insert a new ENTRY containing PASSWORD."
    (interactive (list (read-string "Password entry: ")
                       (read-string "Login: ")
                       (read-passwd "Password: " t)))
    (message "%s" (shell-command-to-string
                   (if (string= "" login)
                       (format "echo %s | %s insert -m -f %s"
                               (shell-quote-argument password)
                               password-store-executable
                               (shell-quote-argument entry))
                     (format "echo -e '%s\nlogin: %s' | %s insert -m -f %s"
                             password login password-store-executable
                             (shell-quote-argument entry)))))))

#+end_src

** password-otp
#+begin_src emacs-lisp :lexical t
(use-package password-store-otp
  :ensure (password-store-otp :version (lambda (_) "0.1.5"))
  :defer t
  :config
  (defun password-store-otp-append-from-image (entry)
    "Check clipboard for an image and scan it to get an OTP URI,
append it to ENTRY."
    (interactive (list (read-string "Password entry: ")))
    (let ((qr-image-filename (password-store-otp--get-qr-image-filename entry)))
      (when (not (zerop (call-process "screencapture" nil nil nil
                                      "-T5" qr-image-filename)))
        (error "Couldn't get image from clipboard"))
      (with-temp-buffer
        (condition-case nil
            (call-process "zbarimg" nil t nil "-q" "--raw"
                          qr-image-filename)
          (error
           (error "It seems you don't have `zbar-tools' installed")))
        (password-store-otp-append
         entry
         (buffer-substring (point-min) (point-max))))
      (when (not password-store-otp-screenshots-path)
        (delete-file qr-image-filename)))))
#+end_src

* rainbow-mode
Colorize strings that represent colors.
This will fontify with colors the string like "#aabbcc" or "blue".
Мы должны включать это сами или какие-то моды должны хук кидать ?
Что делает мод понятно. 

#+begin_src emacs-lisp :lexical t
(use-package rainbow-mode
  :commands (rainbow-mode))
#+end_src
* rainbow-delimiters
#+begin_src emacs-lisp :lexical t
(use-package rainbow-delimiters
  :hook (prog-mode . rainbow-delimiters-mode))
#+end_src

* re-builder (regular expressions)
#+begin_src emacs-lisp :lexical t
(use-feature re-builder
  :custom
  (reb-re-syntax 'rx)
  :commands (re-builder))
#+end_src
* recentf 
#+begin_src emacs-lisp :lexical t
(use-feature recentf
  :defer 1
  :config (recentf-mode)
  :custom
  (recentf-max-menu-items 1000 "Offer more recent files in menu")
  (recentf-max-saved-items 1000 "Save more recent files"))
#+end_src
* TODO shr-color 
#+begin_src emacs-lisp :lexical t :tangle no
(use-feature shr-color
  :custom
  (shr-color-visible-luminance-min 85 "For clearer email/eww rendering of bg/fg colors")
  (shr-use-colors nil "Don't use colors (for HTML email legibility)"))
#+end_src
* custom-set-variables
#+begin_src emacs-lisp :lexical t
(use-feature cus-edit
  :custom
  (custom-file null-device "Don't store customizations"))
#+end_src
* edebug
#+begin_src emacs-lisp :lexical t
(use-feature edebug
  :general
  (global-leader
    :major-modes '(emacs-lisp-mode lisp-interaction-mode t)
    :keymaps     '(emacs-lisp-mode-map lisp-interaction-mode-map)
    "d" '(:ignore t :which-key "debug")
    "dA" 'edebug-all-defs
    "db" '(:ignore t :which-key "breakpoint")
    "dbU"  'edebug-unset-breakpoints
    "dbc"  'edebug-set-conditional-breakpoint
    "dbg"  'edebug-set-global-break-condition
    "dbn"  'edebug-next-breakpoint
    "dbs"  'edebug-set-breakpoint
    "dbt"  'edebug-toggle-disable-breakpoint
    "dbu"  'edebug-unset-breakpoint
    "dw" 'edebug-where))
#+end_src
* elfeed
#+begin_src emacs-lisp :lexical t
(use-package elfeed
  :commands (elfeed)
  :config
  (defvar +elfeed-feed-file (expand-file-name "~/OrgFiles/elfeed.org"))

  (setq elfeed-feeds
        (with-current-buffer (find-file-noselect +elfeed-feed-file)
          (save-excursion
            (save-restriction
              (org-fold-show-all)
              (goto-char (point-min))
              (let ((found nil))
                (org-element-map (org-element-parse-buffer) 'link
                  (lambda (node) (when-let ((props (cadr node))
                                            (standards (plist-get props :standard-properties))
                                            (tags (org-get-tags (aref standards 0)))
                                            ((member "elfeed" tags))
                                            ((not (member "ignore" tags))))
                                   (push (cons (plist-get props :raw-link)
                                               (delq 'elfeed (mapcar #'intern tags)))
                                         found)))
                  nil nil t)
                (nreverse found))))))

  (defun +elfeed-play-in-mpv ()
    "Play selected videos in a shared mpv instance in chronological order."
    (interactive)
    (mapc (lambda (entry)
            (emp-open-url (elfeed-entry-link entry))
            (message "Playing %S in MPV" (elfeed-entry-title entry)))
          (nreverse (elfeed-search-selected)))
    (elfeed-search-untag-all-unread))

  (defun +elfeed-download ()
    "Download selected videos."
    (interactive)
    (let ((default-directory (expand-file-name "~/Videos/youtube")))
      (dolist (entry (nreverse (elfeed-search-selected)))
        (let ((title (elfeed-entry-title entry)))
          (message "Attempting to download %S" (elfeed-entry-title entry))
          (make-process
           :name "elfeed-download"
           :buffer "elfeed-download"
           :command (list "youtube-dl" (elfeed-entry-link entry))
           :sentinel (lambda (process _event)
                       (when (= 0 (process-exit-status process))
                         (message "Successfully downloaded %S" title))))))
      (elfeed-search-untag-all-unread)))
  :general
  (+general-global-application
    "e"    'elfeed)
  (general-define-key
   :states '(normal)
   :keymaps 'elfeed-search-mode-map
   "p" '+elfeed-play-in-mpv
   "d" '+elfeed-download)
  (general-define-key
   :states '(normal)
   :keymaps 'elfeed-show-mode-map
   "J" 'elfeed-show-next
   "K" 'elfeed-show-prev))
#+end_src
* elisp-mode
#+begin_src emacs-lisp :lexical t
(use-feature elisp-mode
  :general
  (global-leader
    :major-modes '(emacs-lisp-mode lisp-interaction-mode t)
    :keymaps     '(emacs-lisp-mode-map lisp-interaction-mode-map)
    "e"  '(:ignore t :which-key "eval")
    "eb" 'eval-buffer
    "ed" 'eval-defun
    "ee" 'eval-expression
    "ep" 'pp-eval-last-sexp
    "es" 'eval-last-sexp
    "i"  'elisp-index-search))
#+end_src
* epa/g-config 
#+begin_src emacs-lisp :lexical t
(use-feature epg-config
  :defer t
  :init (setq epg-pinentry-mode 'loopback))
#+end_src

#+begin_src emacs-lisp :lexical t
(use-feature epa-file
  :defer t
  :init (setq epa-file-cache-passphrase-for-symmetric-encryption t))

#+end_src
* find-func 
#+begin_src emacs-lisp :lexical t
(use-feature find-func
  :defer t
  :config (setq find-function-C-source-directory
                (expand-file-name "~/repos/emacs/src/")))
#+end_src

* fill - column-indicator 
#+begin_src emacs-lisp :lexical t
(use-feature display-fill-column-indicator
  :custom
  (display-fill-column-indicator-character
   (plist-get '( triple-pipe  ?┆
                 double-pipe  ?╎
                 double-bar   ?║
                 solid-block  ?█
                 empty-bullet ?◦)
              'triple-pipe))
  :general
  (+general-global-toggle
    "F" '(:ignore t :which-key "fill-column-indicator")
    "FF" 'display-fill-column-indicator-mode
    "FG" 'global-display-fill-column-indicator-mode))
#+end_src
* fontify-face 
#+begin_quote
Fontify symbols representing faces with that face.

https://github.com/Fuco1/fontify-face
#+end_quote

#+begin_src emacs-lisp :lexical t
(use-package fontify-face
  :commands (fontify-face-mode))
#+end_src
* fountain-mode
#+begin_quote
Fountain Mode is a screenwriting program for GNU Emacs using the Fountain plain text markup format.

https://github.com/rnkn/fountain-mode
#+end_quote
#+begin_src emacs-lisp :lexical t
(use-package fountain-mode
  :ensure (fountain-mode :host github :repo "rnkn/fountain-mode")
  :mode "\\.fountain\\'")
#+end_src
* transient
#+begin_src emacs-lisp :lexical t
(use-package transient :defer t
  :ensure(transient :host github :repo "magit/transient"))
#+end_src
* forge 
#+begin_quote
Work with Git forges from the comfort of Magit
#+end_quote

https://github.com/magit/forge

#+begin_src emacs-lisp :lexical t
(use-package forge
  :ensure (:files (:defaults "docs/*"))
  :after magit
  :init (setq forge-add-default-bindings nil
              forge-display-in-status-buffer nil
              forge-add-pullreq-refspec nil))
#+end_src

* help
#+begin_src emacs-lisp :lexical t
(use-feature help
  :defer 1
  :custom
  (help-window-select t "Always select the help window"))
#+end_src
* helpfull
#+begin_src emacs-lisp :lexical t
(use-package helpful
    :init (setq evil-lookup-func #'helpful-at-point)
    :bind
    ([remap describe-function] . helpful-callable)
    ([remap describe-command] . helpful-command)
    ([remap describe-variable] . helpful-variable)
    ([remap describe-key] . helpful-key))
  ;; :general
  ;; (general-define-key
  ;; :bind (("C-h e F" . helpful-function)
  ;;        ("C-h e C" . helpful-command)
  ;;        ("C-h e M" . helpful-macro)
  ;;        ("C-h e L" . helpful-callable)
  ;;        ("C-h e S" . helpful-at-point)
  ;;        ("C-h e V" . helpful-variable)))

#+end_src

* holidays
I'd like to see holidays and anniversaries in my org-agenda and calendar
I've removed the default holiday lists that I don't need.
#+begin_src emacs-lisp :lexical t
(use-feature holidays
  :commands (org-agenda)
  :custom
  (holiday-bahai-holidays nil)
  (holiday-hebrew-holidays nil)
  (holiday-islamic-holidays nil)
  (holiday-oriental-holidays nil))
#+end_src
* htmlize
#+begin_quote
This package converts the buffer text and the associated decorations to HTML.

https://github.com/hniksic/emacs-htmlize
#+end_quote
This is necessary for exporting Org files to HTML.
#+begin_src emacs-lisp :lexical t
(use-package htmlize
  :defer t)
#+end_src
* ielm (для elisp)
#+begin_src emacs-lisp :lexical t
(use-feature ielm
  :general
  (global-leader
    :major-modes '(inferior-emacs-lisp-mode)
    :keymaps     '(inferior-emacs-lisp-mode-map)
    "b"  '(:ignore t :which-key "buffer")
    "bb" 'ielm-change-working-buffer
    "bd" 'ielm-display-working-buffer
    "bp" 'ielm-print-working-buffer
    "c"  'comint-clear-buffer)
  ;;@TODO: fix this command.
  ;;This should be easier
  (+general-global-application "i"
    '("ielm" . (lambda ()
                 (interactive)
                 (let* ((b (current-buffer))
                        (i (format "*ielm<%s>*" b)))
                   (setq ielm-prompt (concat (buffer-name b) ">"))
                   (ielm i)
                   (ielm-change-working-buffer b)
                   (next-buffer)
                   (switch-to-buffer-other-window i))))))
#+end_src
* keycast
современная замена command-log-mode и юзлес view-lossage
SPC-h-l надо
#+begin_src emacs-lisp :lexical t
(use-package keycast
  :defer t)
#+end_src
* js2
#+begin_quote
Improved JavaScript editing mode for GNU Emacs

https://github.com/mooz/js2-mode
#+end_quote
#+begin_src emacs-lisp :lexical t :tangle no
(use-package js2-mode
  :commands (js2-mode)
  :mode "\\.js\\'"
  :interpreter (("nodejs" . js2-mode) ("node" . js2-mode)))
#+end_src
* magit
#+begin_src emacs-lisp :lexical t
(use-package magit
  :ensure (magit :host github :repo "magit/magit")
  :defer t
  :after (general)
  :custom
  (magit-repository-directories (list (cons elpaca-repos-directory 1)))
  (magit-diff-refine-hunk 'all)
  :general
  (+general-global-git/version-control
    "g"  '(magit-status :wk "Magit status")
    "G"  'magit-status-here
    "b"  'magit-branch
    "B"  'magit-blame
    "c"  'magit-clone
    "f"  '(:ignore t :which-key "file")
    "ff" 'magit-find-file
    "fh" 'magit-log-buffer-file
    "i"  'magit-init
    "L"  'magit-list-repositories
    "m"  'magit-dispatch
    "S"  'magit-stage-file
    "s"  'magit-status
    "U"  'magit-unstage-file)
  :init
  (setq magit-display-buffer-function #'magit-display-buffer-same-window-except-diff-v1)
  :config
  (transient-bind-q-to-quit))
#+end_src
* macrostep
#+begin_quote
macrostep is an Emacs minor mode for interactively stepping through the expansion of macros in Emacs Lisp source code.

https://github.com/joddie/macrostep
#+end_quote
#+begin_src emacs-lisp :lexical t
(use-package macrostep
  :general
  (global-leader
    :major-modes '(emacs-lisp-mode lisp-interaction-mode t)
    :keymaps     '(emacs-lisp-mode-map lisp-interaction-mode-map)
    "m"  '(:ignore t :which-key "macrostep")
    "me" 'macrostep-expand
    "mc" 'macrostep-collapse
    "mj" 'macrostep-next-macro
    "mk" 'macrostep-prev-macro))
#+end_src
* markdown
#+begin_src emacs-lisp :lexical t
(use-package markdown-mode
  :commands (markdown-mode gfm-mode)
  :mode
  (("README\\.md\\'" . gfm-mode)
   ("\\.md\\'" . markdown-mode)
   ("\\.markdown\\'" . markdown-mode))
  :custom
  (markdown-command "/usr/bin/pandoc")
  :init
  (defun my-markdown-mode-hook()
      (visual-line-mode 1))
    (add-hook 'markdown-mode-hook 'my-markdown-mode-hook)
  )
#+end_src
* minibuffer 
#+begin_src emacs-lisp :lexical t
(use-feature minibuffer
  :custom (read-file-name-completion-ignore-case t)
  :config
  (defun +minibuffer-up-dir ()
    "Trim rightmost directory component of `minibuffer-contents'."
    (interactive)
    (unless (minibufferp) (user-error "Minibuffer not selected"))
    (let* ((f (directory-file-name (minibuffer-contents)))
           (s (file-name-directory f)))
      (delete-minibuffer-contents)
      (when s (insert s))))
  (define-key minibuffer-local-filename-completion-map
              (kbd "C-h") #'+minibuffer-up-dir)
  (minibuffer-depth-indicate-mode))
#+end_src
* miscellany 
* nov 
#+begin_src emacs-lisp :lexical t
(use-package nov
  :ensure (nov :depth nil)
  :custom
  (nov-text-width 80)
  :mode
  ("\\.epub\\'" . nov-mode)
  :commands
  (nov-mode))
#+end_src
* notmuch
#+begin_src emacs-lisp :lexical t
 (use-feature notmuch
  :commands (notmuch)
  :defer t
  :general
  (+general-global-open
    "m" '(notmuch :which-key "Notmuch"))
  :init
  (setq mail-user-agent 'message-user-agent
        message-mail-user-agent t
        )
  (setq notmuch-search-oldest-first nil
     
      message-send-mail-function 'message-send-mail-with-sendmail
      notmuch-always-prompt-for-sender t ;;test 
      message-kill-buffer-on-exit t
      message-directory "~/Mail"
      message-sendmail-envelope-from 'header
      mail-envelope-from 'header
      notmuch-show-all-tags-list t 
      mail-specify-envelope-from t)
  (setq mail-host-address (system-name))
)
#+end_src
* wgrep
#+begin_src emacs-lisp :lexical t :tangle no
(use-package wgrep
  ;;:defer t
  :init
  (setq wgrep-auto-save-buffer t
        wgrep-change-readonly-file t))
#+end_src
* whitespace
#+begin_src emacs-lisp :lexical t
(use-feature whitespace
  :custom
  (whitespace-display-mappings '((tab-mark ?\t [?› ?\t])))
  ;;(whitespace-global-modes '(prog-mode text-mode))
  (whitespace-line-column nil)
  (whitespace-style '(empty face lines-tail tab-mark tabs trailing))
;;   :init 
;;   (defface hs-ellipsis
;;   '((((class color) (background light)) (:underline t))
;;     (((class color) (background dark)) (:underline t))
;;     (t (:underline t)))
;;   "Face for ellipsis in hideshow mode.")

;;   ;; Use this in whitespace-mode
;; (defun whitespace-change-ellipsis ()
;;   "Change ellipsis when used with `whitespace-mode'."
;;   (when buffer-display-table
;;     (set-display-table-slot buffer-display-table
;;                             'selective-display
;;                             ;;(string-to-vector " … ")
;;                             (let ((face-offset (* (face-id 'hs-ellipsis) (lsh 1 22))))
;;                               (vconcat (mapcar (lambda (c) (+ face-offset c)) " … ")))
;;                             )))
;; (add-hook 'whitespace-mode-hook #'whitespace-change-ellipsis)

;; ;; Use this in non-whitespace modes
;; (set-display-table-slot
;;  standard-display-table
;;  'selective-display
;;  (let ((face-offset (* (face-id 'hs-ellipsis) (lsh 1 22))))
;;    (vconcat (mapcar (lambda (c) (+ face-offset c)) " … ")))))
  )
  
#+end_src
* ws-butler
#+begin_src emacs-lisp :lexical t :tangle no
(use-package ws-butler
  :ensure (ws-butler :host github :repo "hlissner/ws-butler")
  :hook ((text-mode . ws-butler-mode)
         (prog-mode . ws-butler-mode)))
#+end_src
* TODO xref
[[https://github.com/jiegec/emacs.d/blob/35af3f66947e5cfa6879b46d65de1f229802d845/lisp/init-utils.el#L37][emacs.d/lisp/init-utils.el at 35af3f66947e5cfa6879b46d65de1f229802d845 · jieg...]]
#+begin_src emacs-lisp :lexical t
(use-feature xref
;    :bind
;   ;; Mimic VSCode
;;   ("s-<mouse-1>" . xref-find-definitions-at-mouse)
  :custom
  (xref-search-program 'ripgrep)
  )
#+end_src
* novice
#+begin_src emacs-lisp :lexical t
(use-feature novice
  :custom
  (disabled-command-function nil "Enable all commands"))
#+end_src
* zsh aliases highlight
#+begin_src emacs-lisp :lexical t 
(add-to-list 'auto-mode-alist '("/aliases\\'" . sh-mode))
#+end_src
* extras
#+begin_src emacs-lisp :lexical t
(require 'extras)
#+end_src
* edraw
#+begin_src emacs-lisp :tangle no
(use-package edraw 
  :ensure (:host github :repo "misohena/el-easydraw")
  :after org)
#+end_src
* (provide 'init')

#+begin_src emacs-lisp :lexical t
(provide 'init)
;;; init.el ends here
#+end_src

